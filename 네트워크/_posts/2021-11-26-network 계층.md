---
modified: 2021-11-28T13:51:55+09:00
---

---
title: Network 계층과 IP
---

### 1. network 계층의 forwarding

\- network 계층에서는 transport 계층에서 전달받은 세그먼트를 패킷에 담아 이를 다른 네트워크 장치로 보내 최종적으로 그 세그먼트의 목적 네트워크 장치로 보내게 된다.

\- network 계층에서는 **forwarding table**이 구현돼 있어(이 구현은 별도의 알고리즘을 통해 이루어진다), 수신한 패킷의 목적지(IP 주소)를 forwarding table에서 참조하여 forwarding table에 쓰인 **그 패킷이 보내져야 할 알맞은 link 인터페이스**로 그 패킷을 보내게 된다. 

\- 모든 IP 주소마다 개별적으로 그에 해당하는 link 번호를 저장해 두면 forwarding table이 매우 커지게 되므로 forwarding table은 그렇게 구현되어 있지는 않고, 'IP 주소가 이 범위에 해당되면 **(이러한 prefix를 가지면)** x번 link로 보낸다' 라는 식으로 구현되어 있다.

\- 구체적으로, forwarding table의 각 항목은 키값으로 그에 해당하는 IP 주소의 prefix가 저장돼 있어, 현재 라우터가 수신한 패킷의 dest IP 주소가 어떤 항목의 prefix와 일치하는지를 찾아 그에 해당하는 link 번호로 그 패킷을 보내게 된다. 이때, 예를 들어 어떤 항목의 prefix는 0101이고 어떤 항목의 prefix는 010100인데 라우터가 수신한 패킷의 dest IP 주소가 01010001이라면 어떤 prefix의 link 인터페이스를 선택해야 할지 문제가 된다. 일반적으로는 일치하는 길이가 더 긴 prefix를 선택한다(longest prefix matching).


### 2. 패킷의 헤더

\- 패킷의 헤더에는 다음과 같은 필드가 있다.

- IP version: 현재 사용되는 IP의 버전은 4이다.

- source IP 주소

- destination IP 주소

- time to live: 패킷이 네트워크 망 위에 무한루프를 도는 것을 방지하기 위해, IP를 지나가는 모든 패킷에는 '그 패킷이 지나칠 수 있는 라우터 개수'가 할당된다. 예를 들어 time to live가 15로 설정된 패킷은 라우터를 15개 지나가면 사라진다.

- upper layer: 그 패킷에 담긴 세그먼트가 TCP인지 UDP인지를 나타내며, 이 패킷을 수신한 리시버는 이 필드를 참조하여 패킷을 TCP에 올릴지 UDP에 올릴지를 결정한다.

\- 한 패킷에서 헤더가 차지하는 부분은 20B로 정해져 있고, 세그먼트의 헤더가 차지하는 부분은 20B로 정해져 있다. 따라서 패킷 하나가 갖는 오버헤드의 크기는 40B이다. 인터넷 망을 오가는 상당수 패킷이 크기가 40B인데, 이는 그 패킷이 ACK 메시지를 담고 있는 패킷이기 때문이다.


### 3. IP 주소 

#### 1) 개요

IPv4 IP 주소는 총 32비트로, 약 40억 개의 서로 다른 주소를 표현할 수 있다. (보통 8비트씩 끊어 10진수 숫자 네 개로 IP 주소를 표현한다.) 네트워크에 연결된 호스트와 라우터는 하나 이상의 네트워크 인터페이스 장비를 갖고 있으며, 각 네트워크 인터페이스 장비는 각자 고유의 IP 주소를 갖는다. (즉, 라우터 하나는 여러 개의 IP 주소를 가질 수 있다. 이처럼 여러 개의 IP 주소를 갖는 라우터를 두고 '여러 서브넷에 걸쳐있다'라고 한다.) 


#### 2) 계층화

네트워크 상의 각 호스트가 갖는 IP 주소를 호스트 사이 관계에 전혀 무관하게 무작위적으로 할당할 수 있으나, 그런 식으로 IP 주소를 할당하면 forwarding table을 효율적으로 사용하기 위한 규칙을 만들 수 없어 forwarding table이 매우 커지게 된다. 따라서 보통 IP 주소를 계층화하여, IP 주소의 앞 몇자리는 서브넷의 ID로 할당하고 나머지 자리는 그 서브넷 내 호스트들의 ID로 할당한다. 


(1) classfull network

\- 초기 인터넷은 서브넷 iD의 자릿수를 고정해서 사용하였으며(classful network) 최초에 서브넷 ID에 할당된 자릿수는 8자리였다. 독립된 서브넷을 최대 254개까지만 지원했으나 한 서브넷이 가질 수 있는 호스트는 최대 약 1600만 개까지 지원되어 하나의 서브넷이 갖는 호스트의 크기가 매우 커질 것을 고려한 할당 방식이었다. 이후 인터넷이 팽창하여 인터넷이 갖는 서브넷 개수가 늘어나게 되면서, 서브넷 ID에 할당되는 자릿수를 점차 늘려나가게 되었다. 각 서브넷마다 호스트 ID에 할당해야 하는 비트수가 다를 수 있으므로 이를 달리하는 클래스 3개(A, B, C)를 따로 두었다.

- class A: 32비트 중 7비트를 서브넷 ID에 할당하는 방식이다. class A임을 나타내는 비트를 추가로 하나 더 할당하여, IP 주소가 0으로 시작하는 IP 주소를 class A IP 주소로 보았다.

- class B: 32비트 중 14비트를 서브넷 ID에 할당하고, class B임을 나타내는 비트를 추가로 두 개 더 할당한다. IP 주소가 10으로 시작하는 IP 주소는 class B IP 주소로 본다.

- class C: 32비트 중 22비트를 서브넷 ID에 할당하고, class C임을 나타내는 비트를 추가로 두 개 더 할당한다. IP 주소가 11로 시작하는 IP 주소는 class C IP 주소로 본다.

(2) CIDR(classless inter-domain routing)

\- classful network 방식을 사용하던 중 class C을 사용할 수 없는 서브넷이 너무 많아져서 class B 서브넷이 고갈되게 되었고, 이에 따라 서브넷 ID의 자릿수를 고정하지 않는 방식이 등장하게 되었다(이를 CIDR이라 한다). CIDR 방식은 IP 주소 정보를 전송할 때 그와 함께 어디까지가 서브넷의 ID이고 어디서부터 호스트의 ID인지를 알려주는 정보(서브넷 마스크)를 함께 전송한다. (서브넷 마스크는 보통 서브넷 ID로 할당된 부분을 1로, 호스트 ID로 할당된 부분을 0으로 표현한 IP 주소로 표현된다. 한편, IP 주소 뒤에 /를 쓰고 그 뒤에 서브넷 ID의 자릿수를 적는 경우도 있다. 예를 들어, IP 주소가 192.168.0.1이고 서브넷 마스크가 255.255.255.0이라면 이를 192.168.0.1/24로 표현할 수도 있다.)



#### 3) NAT(network access translation)

\- NAT 기술을 사용한 라우터에 연결된 호스트들은 인터넷에 연결돼 있더라도 다른 호스트와 동일한 IP 주소를 갖고도 인터넷 통신을 할 수 있다. 그 라우터에 연결된 호스트들은 대외적으로는 그 라우터의 IP 주소를 갖는 것으로 간주되며, 대내적으로는 각자 다른 IP 주소를 갖는 것으로 취급된다. 대내적/대외적 IP 주소가 라우터를 거치며 대외적/대내적 IP 주소로 번역되는 것이다. (각 호스트는 포트 번호로 구분한다.)

\- NAT 기술을 사용하면 (1)보안상으로 이점이 있고 (2)IP 주소에만 128비트를 사용하는 IPv6를 사용하지 않고도 인터넷 통신을 할 수 있어 IP 패킷의 오버헤드를 줄이면서 IPv4에 허용되는 호스트 수보다 더 많은 호스트로 인터넷을 사용할 수 있다는 장점이 있다. 그러나 (1)network 계층에 해당하는 패킷의 헤더까지만 통제해야 할 라우터가 패킷에 적힌 IP 주소를 번역하기 위해 세그먼트의 헤더를 변경하는 일이 발생하는 것을 감수해야 한다. (이를 layer violation이라 한다.) 또, (2)프로세스를 구분하기 위해 사용해야 할 포트 번호를 호스트를 구분하는 데 사용하게 되어 어떤 호스트의 어떤 프로세스를 찾아가야 하는지 알 수 없는 경우가 발생할 수도 있다.



### 4. DHCP(dynamic host configuration protocol)

\- 서브넷에 연결된 적 있는 모든 호스트가 각각 고정된 IP 주소를 갖고 있다면 그 호스트들은 별도 절차 없이 바로 그 IP 주소를 통해 인터넷 망에 연결될 수 있을 것이나, 그 서브넷이 가질 수 있는 호스트 ID의 개수가 너무 적어 모든 호스트에게 고정된 IP 주소를 할당할 수 없는 경우가 있다. 모든 호스트가 인터넷 망을 당장 사용하고 있지 않은데 고정 IP 주소를 모두 할당해두는 것은 과도한 낭비이므로, 당장 인터넷 통신을 하고자 하는 호스트들에 한해 그때마다 IP 주소를 동적으로 할당하도록 하는 방법(DHCP)이 있다.

\- 어떤 서브넷이 DHCP 방식으로 IP 주소를 할당하는 경우 그 서브넷에 접속한 호스트에게 IP 주소를 할당해 주는 DHCP 서버가 있다. 그런데 이제 막 서브넷에 접속한 호스트는 어떤 IP 주소에 DHCP 서버가 있는지 알 수 없으므로, 서브넷에 속한 모든 호스트의 IP 주소를 향해 IP 주소 할당을 요청하는 패킷을 전송(브로드캐스트)한다. (이 단계를 discover 단계라 한다.) 이때 보통 DHCP 서버만 개방하고 있는 포트 번호가 있기 때문에, 그 포트 번호를 향해 브로드캐스트를 하면 그 포트 번호가 개방돼 있는 경우에만 그 패킷이 그 호스트(DHCP 서버)에 전달되고 그 외 경우에는 패킷이 소멸한다.

\-
