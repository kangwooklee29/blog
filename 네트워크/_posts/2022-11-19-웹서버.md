### 1. 웹서버 프로그램

\- 외부로부터 웹페이지 요청이 들어왔을 때 그 요청을 처리하여 웹페이지를 전송하는 일련의 과정을 수행하는 프로그램을 웹서버라 한다. 웹페이지 요청에 응답하는 PC까지 포함하여 포괄적 표현으로서 웹서버라 칭하는 경우도 있지만, 보통 웹서버라 하면 동적 컨텐츠를 생성하는 WAS(web application server)와 구분하여 정적 컨텐츠만을 클라이언트에 전송하는 프로그램의 개념으로서 칭하는 경우가 많다.


### 2. 웹서버 프로그램의 종류

#### 1) Apache HTTP Server

\- WWW 역사 초기에 널리 쓰인 웹서버 프로그램으로 미국 국립 슈퍼컴퓨팅 응용 센터(NCSA)에서 개발한 NCSA HTTPd가 있는데, 이 프로그램은 소스코드가 공개되어 누구나 무료로 사용할 수 있는 프로그램이었다. 그런데 1994년 이 프로젝트가 중단되자, 이 프로젝트가 지속되어야 한다고 생각한 개발자 몇몇이 모여 1995년 2월 NCSA HTTPd의 코드에 기반한 새 웹서버 프로그램을 개발하기 시작했다. 이들은 아메리카 원주민인 아파치족의 이름을 따 자신들을 아파치 그룹(Apache group)이라 칭했으며, 자신들의 웹서버 프로그램을 아파치 HTTP 서버라 이름지었다. 아파치 HTTP 서버는 이후 계속 개발되어 현재도 세계적으로 널리 쓰이는 웹서버 프로그램이며, 이 아파치 그룹은 1999년 아파치 소프트웨어 재단으로 발전해 현재도 여러 오픈소스 프로젝트를 운영하고 있다.

\- 아파티 HTTP 서버는 호환성 및 확장성이 뛰어나고 사용자 커뮤니티가 강력하다는 등 많은 장점이 있지만, 동시에 접속하는 클라이언트 수가 크게 증가했을 때 이를 처리하는 성능이 매우 떨어진다는 점(C10k problem) 때문에 대규모 트래픽을 처리하는 웹서버의 경우 다른 웹서버 프로그램을 사용한다.

- 아파치 HTTP 서버는 새 클라이언트와 연결을 형성할 때마다 매번 새 스레드와 소켓을 생성하는 방식으로 클라이언트와의 연결을 관리한다(process-driven). 그런데 이와 같은 관리 방식은 네트워크 관련 I/O를 할 때(버퍼에서 데이터를 받아오거나 보낼 때) 스레드 전체가 blocked 상태로 전환돼야 하고, 이 경우 그 스레드가 그 연결에 관한 처리를 할 수 없고 대기 상태에 오래 머무르게 된다. 프로세스/스레드가 아주 많지는 않다면 대기 상태에 머무르는 시간이 아주 길지는 않을 수 있으나 클라이언트 연결 수가 많아진다면 CPU는 여유가 있는데 I/O로 인해 스레드 전체가 blocked 상태에 머무르는 시간이 크게 늘어나게 된다. 이것이 아파치 HTTP 서버가 갖는 C10k 문제의 구조적인 원리이다.

- 특히 아파치 HTTP 서버는 HTTP/1.1부터 기본 설정이 된 HTTP Keep-Alive에 관한 문제가 있는데, Keep-Alive는 TCP 통신이 끝난 후 바로 TCP 연결을 끊지 않고 일정 시간 대기하는 상태로 이 상태가 기본 설정이 돼 종전보다 추가로 스레드가 blocked 상태에 머무르는 시간이 길어졌다는 점이다. 이 문제를 해소하기 위해 아파치 HTTP 서버는 클라이언트 연결을 스레드를 통해 관리하는 새로운 방식을 사용했으나(클라이언트로부터 데이터를 전달받는 작업만을 처리하는 스레드를 별개로 두어 그 스레드가 TCP 연결을 형성하는 작업을 전담으로 처리하도록 하고, TCP 연결이 생성되면 그때 그 연결에 대한 작업을 수행하는 스레드로 TCP 연결을 넘기는 구조로, 이를 event MPM라 한다) 이 역시 C10k 문제를 해결하는 데는 한계가 있다.



#### 2) NGINX

\- 2004년 러시아의 프로그래머 이고르 시쇼브가 C10k 문제를 겪는 아파치 HTTP 서버의 대안으로 발표한 오픈소스 웹서버 프로그램으로, 서버-클라이언트 연결을 관리하는 구조가 아파치 HTTP 서버와는 전혀 다르다. 굉장히 가볍고 뛰어난 성능으로 C10k 문제가 없어 현재 아파치 HTTP 서버 못잖은 수준으로 큰 인기를 누리고 있다.

\- 새 클라이언트와 연결을 새로 형성할 때마다 이를 전담하는 스레드를 새로 생성하는 아파치 HTTP 서버와 달리, NGINX는 하나의 스레드(+하나의 소켓)가 여러 클라이언트와의 연결을 한꺼번에 관리한다. 클라이언트로부터 데이터가 들어오거나 내보내는 사건(event) 하나를 한 단위로 해서, 일련의 이벤트를 순서대로 하나씩 대기열에 넣은 후 대기열에서 이벤트를 순서대로 하나씩 꺼내 처리하는 방식(event-driven)을 사용한다. (각 클라이언트로부터 전달받은 이벤트를 대기열에 넣는 작업을 수행하는 부분을 event handler라 하며, 스레드가 대기 상태에 있다가 대기열에 이벤트가 들어오면 이를 처리한 후 다시 대기 상태로 돌아간다는 점에서 이를 수행하는 부분을 event loop라 한다. 대기열에서 이벤트를 순서대로 꺼내오지만 한 이벤트를 꼭 끝까지 다 처리한 다음 다음 이벤트를 가져오는 건 아니라는 점에서 NGINX의 이벤트 처리방식은 비동기적이다.) 

- thread pool: 대기열에서 가져온 어떤 이벤트를 처리하는데 I/O에 소모되는 시간이 긴 경우, 그 이벤트의 I/O만을 처리하는 스레드를 새로 만들고 그 이벤트를 그 스레드가 전담하여 처리하도록 한다. 이처럼 I/O에 소모되는 시간이 긴 이벤트를 전담 처리를 하는 스레드들을 묶어서 thread pool이라 한다.

- NGINX의 장점: 하나의 스레드가 클라이언트와의 연결을 모두 관리하므로 context switch로 인한 오버헤드가 없다. I/O로 인해 스레드가 blocked 상태가 되어 다른 작업을 수행하지 못하는 일이 일어나지 않는다.

- NGINX의 단점: 프로세스 자체의 오류로 인해 프로세스가 종료되면 그와 연결돼 있던 클라이언트와 연결이 모두 끊어지고 클라이언트로부터 요청받아 처리중이던 작업도 모두 중단된다. 

\- 아파치 HTTP 서버는 자체적으로 동적 컨텐츠도 처리하는 WAS로서의 기능도 있지만, NGINX는 기능이 매우 간소해 WAS로서의 기능 없이 정적 컨텐츠만을 처리한다는 차이가 있다. 
