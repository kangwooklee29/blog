### 1. link state 알고리즘

\- 모든 라우터와 호스트들의 연결상태를 알고 있다면, 이를 그래프로 그린 후 **다익스트라 알고리즘**을 통해 센더에서 리시버로 가는 경로를 구할 수 있다.

\- link state 알고리즘은 네트워크의 모든 연결상태를 알아야 사용할 수 있으므로, 네트워크 상의 모든 호스트와 라우터들이 각자 자신과 인접한 라우터/호스트의 연결상태를 브로드캐스트로 네트워크 내 모든 라우터/호스트에게 알려주어야 그때 비로소 link state 알고리즘을 사용할 수 있다. 인터넷의 모든 라우터/호스트가 link state 알고리즘을 위하여 자신의 연결상태를 브로드캐스트하는 것은 지나친 자원 낭비가 될 수 있으므로 그 정도 규모에서는 사용하기 어려운 알고리즘이나, 라우터/호스트가 수백 대 정도 되는 규모에서는 사용하기 용이한 알고리즘이다. 


### 2. distance vector 알고리즘

\- 네트워크 상의 모든 호스트/라우터(정점) 사이 최단거리를 vector(배열과 유사한 자료구조)로 표현할 때(이를 distance vector라 하자) 네트워크 상의 모든 호스트/라우터는 각자 자신만의 distance vector를 갖는다. 이 distance vector를 기호로 표현하여, 네트워크 상의 임의의 정점 x에서 또 다른 임의의 정점 z까지 최단거리를 \\(d_x (z)\\)라 하고 정점 x에서 인접한 정점 y로 이동할 때 비용을 \\(c_x (y)\\)라 할 때, \\(d_x (z)\\) = min { \\(c_x (y)\\) + \\(d_y (z)\\) } 라는 식을 쓸 수 있다. (이 식을 Bellman-Ford equation이라 한다.)

\- 호스트/라우터 사이 아무런 정보 교환이 없었고 각 호스트/라우터는 자신과 인접한 호스트/라우터까지의 전송 시간만을 알고 있다고 할 때, 각 호스트/라우터는 자신이 가지고 있는 distance vector를 인접한 라우터로 전송한 후 이를 전송받은 호스트/라우터는 BF eq를 통해 자신이 갖고 있는 distance vector에서 정보가 없던 숫자를 채워나갈 수 있다. distance vector 알고리즘은 이처럼 네트워크 상의 각 호스트/라우터가 서로 distance vector를 전송하여 BF eq로 distnace vector 상의 채워지지 않은 숫자를 채워나가 목표하는 호스트/라우터까지의 최단거리를 알게 되는 알고리즘이다.

\- 만약 어느 한 간선의 비용이 종전보다 증가하거나 감소하거나 간선이 아예 끊기거나 하는 등의 변화가 발생할 경우, 이 정보는 그에 인접한 호스트/라우터가 갖고 있던 distance vector의 값에 반영되어 그 distance vector가 차례대로 네트워크 상의 모든 호스트/라우터에 전달됨으로써 각 호스트/라우터의 distance vector에 반영되게 된다. 

- 그런데 각 호스트/라우터가 갖고 있던 distance vector의 어떤 값들은 주변에서 distance vector를 전달받아 이를 반영하여 계산을 다시 한 뒤에도 변화 이전의 정보를 아직 갖고 있는 경우가 있다. 예를 들어 A-B-C 세 정점이 서로 연결돼 있는 그래프가 있고 이 그래프는 C에서 B로 가는 경로가 직접 이동하는 비용(50)보다 A를 거쳐 가는 비용(1+1)이 더 적은 그래프라고 하자. 그렇다면 A와 B는 'C에서 B로 갈 때 최소비용은 2'라는 정보를 가지고 있다. 그런데 여기서 만약 A에서 B로 이동하는 간선이 끊어진다면, A가 갖고 있는 distance vector에서 A에서 B로 이동하는 최소비용은 **51이 아니라 3**으로 업데이트 되게 된다. A에에서 B로 이동하는 간선이 끊어졌으므로 1이라는 값이 지워지게는 되었지만, 그것만으로 C에서 B로 가는 최소비용이 2라는 정보까지 같이 지워지는 것은 아니기 때문이다. 더 큰 문제는, distance vector를 갱신한 후 다른 정점으로 distance vector를 보내는 작업을 무한히 반복하게 된다는 점이다. (distance vector를 받을 때마다 이 값이 어느 한 점에서 멈추는 게 아니라 계속 증가하기 때문이다.) 이 문제를 count-to-infinity 문제라 한다.

- A가 B, C로부터 distance vector를 받을 때 거기 있는 정보 중에 자신을 경유하여 만들어진 최소비용이 있다면 그 최소비용을 무한대로 보고 자신을 경유하지 않은 정보들만으로 자신의 distance vector를 갱신하게 함으로써 이 문제를 해결할 수 있다. (이를 poisoned reserve라 한다.)

\- distance vector 알고리즘은 link state 알고리즘과 같은 브로드캐스트 문제는 발생하지 않으나, 대신 각 호스트/라우터가 갖고 있는 distance vector의 크기가 네트워크 상의 호스트/라우터의 개수의 제곱에 비례해 커진다는 점에서 link state 알고리즘 못지않게 네트워크 자원 낭비가 있을 수 있다.


### 3. AS(autonomous system)

\- 특정 관리자의 관할 안에 있는 네트워크를 AS라 하며, 전세계에는 이러한 AS가 6만여개 정도 있다. AS들도 각자 규모가 다 다르고, AS끼리는 서로 수직적 관계가 있을 수도 있고 수평적 관계가 있을 수도 있다. 

\- AS 안에서는 link state 또는 distance vector 알고리즘을 쓸 수 있으나, AS끼리는 이들 알고리즘을 쓰지 않는다. 관리 주체가 서로 다른 경우에는 데이터 통신을 빠르게 하는 것보다 더 고려할 문제가 많기 때문이다. 예를 들어 한 AS에서 다른 AS로 데이터를 전송할 수 있는 경로가 여럿 있더라도, AS의 정책에 따라 최단경로가 아니라 최대 수익을 얻을 수 있는 경로를 선택하여 데이터를 전송하는 경우가 있다. 또는, 정보 보안의 측면에서 신뢰할 수 없는 AS를 최대한 회피하여 데이터 전송 경로를 선택하는 경우를 생각할 수 있다.