### 1. 개요

\- link 계층보다 상위 계층에서 네트워크 통신을 이야기할 땐, 한 호스트/라우터에서 다른 호스트/라우터로의 통신이 '이쪽에서 저쪽으로 패킷을 보내면 저쪽에서 패킷을 받을 수도 있고 중간에 유실될 수도 있다'라는 식으로 이야기해왔으나, 실제로는 고려해야 할 문제가 더 많다. 예를 들어, 하나의 게이트웨이에 여러 호스트들이 연결돼 있는 네트워크에서는(이런 네트워크를 LAN, local area network라 한다), **한 호스트에서 발송한 전기신호가 게이트웨이에 연결된 모든 호스트에 전달**되게 된다. (이런 현상이 일어나는 매체를 broadcast medium이라 한다.) 이는 각 호스트와 게이트웨이 사이 경로를 여러 호스트가 공유하기 때문인데, 이러한 방식으로 네트워크가 구현되어 있기 때문에, 여러 호스트에서 동시에 전기 신호를 송신하는 경우 게이트웨이는 **이들 신호가 중첩된 전기신호를 수신하여 다른 라우터로 전달해야 할 정확한 메시지를 파악하지 못하는 일이 발생**한다. (이를 collision이라 한다.) 따라서 link 계층에서는 이러한 문제를 해결하는 것(이를 medium access control 또는 MAC이라 한다)이 중요한 과제가 된다.


### 2. MAC protocol

#### 1) channel partitioning

\- TDMA(time division multiple access): 한 주기를 호스트 수만큼 나누어, **각 시간단위를 각 호스트에게 할당**하여 그 시간에는 그 호스트의 패킷만 전송하는 방식의 프로토콜이다. 당장 전송할 패킷이 없는 호스트에게도 시간 할당이 이루어지기 때문에, 그 시간 동안은 게이트웨이가 아무 패킷도 전송하지 않아 자원 낭비가 발생한다.

\- FDMA(frequency division multiple access): 각 호스트가 사용하는 주파수 대역을 달리하여, **각 주파수 대역을 사용하는 호스트가 유일하게 주파수 대역을 할당**하는 방식의 프로토콜이다. TDMA와 마찬가지로, 당장 전송할 패킷이 없는 호스트에게도 주파수 대역 할당이 이루어지기 때문에 그 주파수 대역은 아무도 사용하지 않는 자원 낭비가 발생한다.

\- CDMA(code division multiple access): 각 호스트마다 고유의 코드를 할당하여, collision이 발생한 전파를 미리 할당된 코드와 연산하여 그 전파에서 그 호스트로 전송한 메시지를 추출해내는 방식의 프로토콜이다.

#### 2) random access

\- Ethernet, Wi-Fi 등이 사용하는 방식의 MAC protocol로, channel partitioning이 특정 자원을 각 호스트에게 독점적으로 할당하여 collision 발생을 원천 차단하는 방식이라면 randome access는 전송할 패킷이 있는 호스트가 일단 즉각적으로 패킷을 전송하게 하여 collision 발생을 일단 감수하되 나름의 방식으로 이를 극복한다.

\- randome access는 channel partitioning에 비하면 자원 낭비가 없다는 장점이 있지만, 네트워크의 호스트가 늘어나면 늘어날수록 그에 비례하여 전송 속도가 느려진다는 단점이 있다.

\- CSMA(carrier sense multiple access): 현재 네트워크 상의 다른 호스트 중에 패킷을 전송한 호스트가 없어질 때까지 기다렸다가 아무도 없을 때 패킷을 전송하는 방식(listen before transmit)의 프로토콜이다. 이 방식을 사용하더라도 collision 문제가 발생할 수 있는데, 현재 네트워크 상에 패킷을 전송한 호스트가 없다고 판단해 패킷을 전송했는데 바로 정확히 그 시점에 다른 호스트가 패킷을 전송하는 경우가 있을 수 있기 때문이다. 

\- CSMA/CD(collision detection): CSMA와 마찬가지로 listen before transmit을 하되, collision이 발생했음을 감지하면 각 호스트는 즉시 전송을 멈춘다. 그리고는 다음과 같은 절차를 따라 재전송을 수행한다.

(1) 현재까지 발생한 collision 횟수가 n이라 할 때, {0, 1, 2, ..., \\(2^(n-1)\\)} 이라는 집합에서 무작위로 하나의 숫자를 고른 후 그 시간만큼 기다렸다가 재전송한다. (이를 binary backoff라 한다.)

(2) 또 다시 collision이 발생했다면 또 즉시 전송을 멈추고 (1)단계로 돌아간다.

- collision이 발생했다는 사실을 알 수는 있지만 그것이 몇개의 호스트가 동시에 충돌한 것인지는 알 수 없으므로, 기다리는 시간을 정확히 알 방법이 없다. 따라서 일정 범위 내 숫자를 무작위적으로 고를 수밖에 없는데, 처음에는 일단 가장 낙관적인 상황(collision의 원인인 호스트가 하나뿐)이라고 추측하고 대기 시간을 골랐다가 그 후 재차 collision이 발생했으면 그때부터 점차 collision 원인으로 추측되는 호스트 개수를 늘려나간다는 것이 binary backoff의 기본 아이디어다.


#### 3) taking turns

\- 게이트웨이에 패킷을 전송할 독점권을 각 호스트에게 돌아가며 부여하는 방식으로, 마스터가 전송할 패킷이 있는 호스트를 조사하여 그 호스트에게 독점권을 부여하는 방식(polling)과 네트워크 상에서 바로 인접한 호스트에게 독점권을 차례대로 양도하는 방식(token-passing)이 있다. token-passing은 네트워크 상의 어느 한 호스트만 고장나도 전체 시스템이 망가지고, polling도 마스터가 고장나면 전체 시스템이 망가진다는 단점이 있다.




### 3. 이더넷 프레임의 헤더

\- 이더넷 프레임의 헤더에는 다음과 같은 필드가 있다.

- source MAC 주소

- destination MAC 주소: 패킷과 달리, 그 프레임이 바로 도착할 게이트웨이의 MAC 주소가 적히게 된다.

- type: 안에 들어있는 패킷의 프로토콜 타입(주로 IP)을 나타낸다.

- CRC: 프레임의 끝부분에 에러체크 등의 목적으로 데이터가 적히게 된다.


\- MAC 주소는 컴퓨터의 랜카드나 라우터 같은 네트워크 접속 장치가 처음 제조사에서 제조될 때 고정되는 그 기기의 고유 식별값으로, broadcast가 일어나는 LAN 환경에서 같은 LAN에 속한 각 장치들이 서로를 식별할 수 있게 하기 위해 사용되는 값이다. 이더넷에서는 source와 destination을 식별하는 고유값으로 각 장치의 MAC 주소를 사용한다. (따라서, 같은 LAN에 속한 두 호스트의 MAC 주소가 서로 동일하다면 둘 중 한 쪽만이 정상적인 인터넷 통신이 가능하다.) MAC 주소는 48비트로 이루어져 있으며, 앞자리 24비트는 제조사의 고유 식별값이고 뒷자리 24비트는 그 제조사에서 제조된 그 제품 고유 식별값이다.



\- broadcast medium에서는 데이터를 전송하는 동안 collision이 발생하지 않았다면 데이터가 문제 없이 게이트웨이에 잘 전달됐다고 볼 수 있으므로, 이더넷은 TCP에서와 같이 별도의 ACK 메시지가 존재하지는 않는다. 단, 만약 **전송하는 프레임 길이가 너무 짧으면**, 이쪽 호스트(A)에서는 전송이 다 끝났는데 그 게이트웨이에 연결된 다른 호스트(B)가 A가 프레임을 전송했다는 사실을 모르고 따로 프레임을 발송해 게이트웨이가 A의 프레임을 다 받아들이기 전에 B의 프레임과 A의 프레임이 **collision을 일으키는 경우**가 발생할 수도 있다. 이러한 문제가 발생하지 않으려면 각 호스트가 발송하는 **프레임의 길이가 너무 짧지만 않으면 된다.** 이더넷의 경우 이러한 문제에 대비하여 최소 프레임 길이를 64B로 두고 있다.




### 4. ARP(address resolution protocol)


#### 1) ARP 테이블을 통한 IP 주소 - MAC 주소 매핑


\- 각 호스트/라우터는 내부적으로 **ARP 테이블**을 두고 있는데, 이 테이블은 **그와 인접한 다른 호스트/라우터의 IP 주소에 대응되는 MAC 주소**가 적혀 있다. 구체적으로 ARP 테이블을 다음과 같이 사용하여 network 계층으로부터 전달받은 패킷을 그것의 dest IP 주소가 있는 곳으로 전송한다.

(1) 패킷을 network 계층으로부터 전달받았을 때, link 계층에서는 그 패킷 헤더에 있는 dest IP 주소에 대응되는 **MAC 주소를 ARP 테이블에서 찾아내 이를 프레임의 dest MAC 주소에 적어 LAN으로 브로드캐스트** 한다. 

(2) 호스트가 브로드캐스트 한 프레임은 서브넷 내 모든 호스트/라우터에 전달된다. 이때 만약 이를 수신한 호스트/라우터의 MAC 주소가 그 프레임에 적힌 dest MAC 주소와 일치한다면 그 호스트/라우터는 그 프레임을 network 계층으로 올려 보낸다. (일치하지 않는다면 폐기한다.)


#### 2) ARP 테이블을 채우는 절차

\- 패킷을 보내려고 하는 dest IP 주소에 대응되는 MAC 주소가 ARP 테이블에 없는 경우에는, 다음 절차를 거쳐 ARP 테이블을 채운다.

(1) 호스트/라우터는 ARP request라는 프레임에 dest IP 주소를 적어 **브로드캐스트** 한다. 

(2) 이를 수신한 호스트/라우터는 자신의 MAC 주소를 그 헤더에 적은 프레임을 반환한다. 

(3) 그 프레임을 수신한 호스트/라우터는 그 헤더에 적인 MAC 주소를 보고 이를 ARP 테이블의 빈칸을 채운다.

#### 3) ARP 테이블의 특성

\- ARP 테이블은 캐시 테이블에 해당하며, ARP 테이블에 저장된 정보는 일정 시간(그 항목의 TTL값)이 지나면 사라진다.



### 5. 스위치

\- 예전에는 LAN의 각 호스트 사이에 아무런 장치 없이 유선 케이블이 연결돼 있어 LAN에 속한 호스트끼리는 무조건 collision의 가능성이 있었는데, 요즘은 웬만하면 중간에 스위치라는 장치를 두어 collision domain을 분리하고 있다. 스위치의 각 포트에는 각 호스트와 연결되는 케이블이 각각 꽂혀 있어, 스위치는 각 호스트에서 오는 전기신호를 받아 다른 호스트로 이를 전송하는 기능이 있다.

\- 스위치는 내부적으로 스위치 테이블을 두고 있는데, 이 테이블은 각 MAC 주소에 해당하는 호스트가 몇번 포트에 연결되어 있는지가 적혀 있다. 스위치는 호스트로부터 수신한 프레임의 dest MAC 주소에 대응되는 포트 번호를 스위치 테이블에서 찾아내 그 프레임을 그 포트로 전송한다.

\- 스위치 테이블은 다음 알고리즘을 통해 채우게 된다.

- 스위치가 수신한 프레임의 헤더 내 source MAC 주소가 스위치 테이블에 없는 경우: 스위치 테이블에 그 MAC 주소의 포트 번호를 그 프레임을 전송한 포트번호로 적는다. (**스위치가 스위치 테이블을 채우는 방식은 이처럼 단순하게 그 자신으로 들어오는 프레임의 내용을 읽고 그 내용을 스스로 채우는 방법이 전부**다. 따라서 이 알고리즘의 이름을 self-learning이라 한다.)

- 프레임을 보내려 하는 dest MAC 주소에 대응되는 MAC 주소가 스위치 테이블에 없는 경우: 스위치는 **프레임을 모든 포트에 전송**한다(flooding). (**이쪽에서 프레임 전송이 있었으면 그쪽으로 도달하는 프레임 전송이 또 올 것**이고, 그때 저 dest MAC 주소에 대응되는 포트번호가 스위치 테이블에 채워질 것이다. flooding은 무한히 일어나는 사건은 아닌 것이다.)

