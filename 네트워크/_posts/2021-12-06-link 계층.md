### 1. 개요

\- link 계층보다 상위 계층에서 네트워크 통신을 이야기할 땐, 한 호스트/라우터에서 다른 호스트/라우터로의 통신이 '이쪽에서 저쪽으로 패킷을 보내면 저쪽에서 패킷을 받을 수도 있고 중간에 유실될 수도 있다'라는 식으로 이야기해왔으나, 실제로는 고려해야 할 문제가 더 많다. 예를 들어, 하나의 게이트웨이에 여러 호스트들이 연결돼 있는 네트워크에서는, **한 호스트에서 발송한 전기신호가 게이트웨이에 연결된 모든 호스트에 전달**되게 된다. (이런 현상이 일어나는 매체를 broadcast medium이라 한다.) 이는 각 호스트와 게이트웨이 사이 경로를 여러 호스트가 공유하기 때문인데, 이러한 방식으로 네트워크가 구현되어 있기 때문에, 여러 호스트에서 동시에 전기 신호를 송신하는 경우 게이트웨이는 **이들 신호가 중첩된 전기신호를 수신하여 다른 라우터로 전달해야 할 정확한 메시지를 파악하지 못하는 일이 발생**한다. (이를 collision이라 한다.) 따라서 link 계층에서는 이러한 문제를 해결하는 것(이를 medium access control 또는 MAC이라 한다)이 중요한 과제가 된다.


### 2. MAC protocol

#### 1) channel partitioning

\- TDMA(time division multiple access): 한 주기를 호스트 수만큼 나누어, **각 시간단위를 각 호스트에게 할당**하여 그 시간에는 그 호스트의 패킷만 전송하는 방식의 프로토콜이다. 당장 전송할 패킷이 없는 호스트에게도 시간 할당이 이루어지기 때문에, 그 시간 동안은 게이트웨이가 아무 패킷도 전송하지 않아 자원 낭비가 발생한다.

\- FDMA(frequency division multiple access): 각 호스트가 사용하는 주파수 대역을 달리하여, **각 주파수 대역을 사용하는 호스트가 유일하게 주파수 대역을 할당**하는 방식의 프로토콜이다. TDMA와 마찬가지로, 당장 전송할 패킷이 없는 호스트에게도 주파수 대역 할당이 이루어지기 때문에 그 주파수 대역은 아무도 사용하지 않는 자원 낭비가 발생한다.

#### 2) random access

\- Ethernet, Wi-Fi 등이 사용하는 방식의 MAC protocol로, channel partitioning이 특정 자원을 각 호스트에게 독점적으로 할당하여 collision 발생을 원천 차단하는 방식이라면 randome access는 전송할 패킷이 있는 호스트가 일단 즉각적으로 패킷을 전송하게 하여 collision 발생을 일단 감수하되 나름의 방식으로 이를 극복한다.

\- randome access는 channel partitioning에 비하면 자원 낭비가 없다는 장점이 있지만, 네트워크의 호스트가 늘어나면 늘어날수록 그에 비례하여 전송 속도가 느려진다는 단점이 있다.

\- CSMA(carrier sense multiple access): 현재 네트워크 상의 다른 호스트 중에 패킷을 전송한 호스트가 없어질 때까지 기다렸다가 아무도 없을 때 패킷을 전송하는 방식(listen before transmit)의 프로토콜이다. 이 방식을 사용하더라도 collision 문제가 발생할 수 있는데, 현재 네트워크 상에 패킷을 전송한 호스트가 없다고 판단해 패킷을 전송했는데 바로 정확히 그 시점에 다른 호스트가 패킷을 전송하는 경우가 있을 수 있기 때문이다. 

\- CSMA/CD(collision detection): CSMA와 마찬가지로 listen before transmit을 하되, collision이 발생했음을 감지하면 각 호스트는 즉시 전송을 멈춘다. 그리고는 다음과 같은 절차를 따라 재전송을 수행한다.

(1) 현재까지 발생한 collision 횟수가 n이라 할 때, {0, 1, 2, ..., \\(2^(n-1)\\)} 이라는 집합에서 무작위로 하나의 숫자를 고른 후 그 시간만큼 기다렸다가 재전송한다. (이를 binary backoff라 한다.)

(2) 또 다시 collision이 발생했다면 또 즉시 전송을 멈추고 (1)단계로 돌아간다.

- collision이 발생했다는 사실을 알 수는 있지만 그것이 몇개의 호스트가 동시에 충돌한 것인지는 알 수 없으므로, 기다리는 시간을 정확히 알 방법이 없다. 따라서 일정 범위 내 숫자를 무작위적으로 고를 수밖에 없는데, 처음에는 일단 가장 낙관적인 상황(collision의 원인인 호스트가 하나뿐)이라고 추측하고 대기 시간을 골랐다가 그 후 재차 collision이 발생했으면 그때부터 점차 collision 원인으로 추측되는 호스트 개수를 늘려나간다는 것이 binary backoff의 기본 아이디어다.


#### 3) taking turns

\- 게이트웨이에 패킷을 전송할 독점권을 각 호스트에게 돌아가며 부여하는 방식으로, 마스터가 전송할 패킷이 있는 호스트를 조사하여 그 호스트에게 독점권을 부여하는 방식(polling)과 네트워크 상에서 바로 인접한 호스트에게 독점권을 차례대로 양도하는 방식(token-passing)이 있다. token-passing은 네트워크 상의 어느 한 호스트만 고장나도 전체 시스템이 망가지고, polling도 마스터가 고장나면 전체 시스템이 망가진다는 단점이 있다.