---
title: TCP
---

### 1. TCP의 segment 헤더

\- TCP의 segement의 헤더는 다음 4개의 필드로 이루어져 있다.

- source port 번호

- destination port 번호

- sequence number

- ACK number: TCP의 센더와 리시버는 모두 반대로 리시버이자 센더이기도 하므로 그 segment의 헤더에는 항상 ACK number가 포함된다. 이때, TCP의 ACK number는 cumulative하다는 점은 go-back-N의 ACK(n) 메시지와 유사하지만 go-back-N의 경우와 달리 '0번부터 n-1번 메시지까지 모두 정상적으로 수신했으며 이제 n번 메시지를 기다리고 있음'이라는 뜻을 가진다.

- checksum


### 2. TCP의 reliable data transfer

\- TCP는 다음과 같은 방식으로 reliable data transfer를 구현한다.

(1) 센더는 여러 개의 메시지를 동시에 송신하며, 송신할 때 타이머를 하나 설정한다. 이때 설정하는 타이머의 시간은 다소 넉넉하게 잡는다.

(2) 리시버는 센더 측 메시지를 수신했다면 feedback으로 ACK(n)을 센더 측에 송신한다. 이는 0번부터 n-1번 메시지까지 정상적으로 수신했음을 뜻한다.

- 리시버 측은 selective repeat 방식과 유사한 버퍼를 사용한다. 즉, 메시지가 번호순대로 정상적으로 수신됐다면 application 계층으로 보내고 번호순이 아닌 메시지가 들어왔다면 일단 이를 버퍼에 저장해 둔다.

\- 만약 센더 측에서 메시지를 수백 개 전송한다 할 때, timeout이 일어나기엔 한참 오랜 시간이 남았는데도 불구하고 매번 리시버 측에서 메시지를 수신할 때마다 ACK(n)를 전송한다면 이는 불필요한 네트워크 자원 낭비가 일어나는 것이라고 볼 수 있다. 따라서 인터넷 표준(RFC)은 ACK 메시지를 충분히 긴 시간 간격을 두고 송신할 것을 권고하고 있다.

\- 한편, 만약 timeout이 발생하기 전에 메시지 유실을 알아챌 수 있는 방법이 있는데도 불구하고 timeout이 일어날 때까지 기다렸다가 재송신을 한다면 이는 시간낭비가 된다고 볼 수 있다. TCP의 feedback 메시지는 cumulative하므로, 리시버 측에서 sequence number가 똑같은 ACK 메시지를 여러 번 전송했다면 그 숫자의 메시지가 유실되었음을 알 수 있다. 이처럼 timeout 이전에 메시지 유실을 알아채고 센더 측이 메시지를 재전송하는 것을 'fast retransmit'이라 한다.



### 3. TCP의 flow control

\- 센더 측에서 리시버 측의 가용 버퍼 크기보다 더 많은 양의 메시지를 보내면 리시버 측 버퍼가 이를 모두 받아들일 수 없으므로 메시지를 일부 잃는 문제가 발생한다. 이러한 일이 발생하지 않으려면 센더 측에서는 리시버 측의 가용 버퍼 크기에 맞는 만큼만 메시지를 보내야 한다. 이처럼 센더 측에서 리시버 측 가용 버퍼 크기에 맞는 만큼의 메시지를 보내도록 하는 것을 flow control이라 한다.

\- 리시버 측이 feedback 시 보내는 메시지에 리시버 측의 가용 버퍼 크기 정보를 담아 전송하여 센더 측이 flow control을 하게 할 수 있다. 다만, 만약 리시버 측 가용 버퍼 크기가 0이라면, 이러한 방식으로 flow control을 하면 센더 측은 영원히 메시지를 송신할 수 없어 영원히 리시버 측 가용 버퍼 크기가 늘어나는지 알 수 없는 문제가 발생한다. 이러한 문제에 대비하여, 실제 TCP에서는 **리시버 측 가용 버퍼 크기가 0이라 하더라도 센더 측에서는 일정 시간 간격으로 더미 데이터를 보내** 리시버 측 가용 버퍼 크기 정보를 얻는다.


### 4. TCP의 connection management


#### 1) connection 구축(3-way handshake)

\- 센더와 리시버 사이 통신이 이뤄지기에 앞서 가장 먼저 양측은 각자 버퍼를 만들어주고 또 앞으로 어떤 sequence number부터 송신하게 될지 등의 문제를 서로 확인하는 작업이 필요하다. 이처럼 통신에 앞서 사전 준비를 거치는 것을 'connection을 구축'한다고 한다.

\- TCP의 connection 구축은 다음 단계를 통해 이루어진다.

(1) 클라이언트가 서버를 향해 SYN 메시지(connection 구축을 요청하는 메시지)를 전송하고, 이를 수신한 서버는 그에 대한 SYN/ACK를 전송한다.

- 이 과정에서 클라이언트와 서버는 반대편을 향해 각자의 sequence number를 전송한다.

- SYN 메시지는 세그먼트의 헤더의 SYN 부분 비트를 1로 설정하는 방식으로 표현한다. SYN/ACK 메시지는 세그먼트의 헤더의 SYN 부분 비트를 1로, ACK 부분 비트도 1로 설정하는 방식으로 표현한다.

(2) SYN/ACK를 수신한 클라이언트는 그에 대한 ACK를 전송한다. 

- SYN/ACK의 수신으로써 클라이언트는 (a)서버가 자신의 sequence number를 정상적으로 수신했다는 사실과 동시에 (b)서버의 sequence number를 알 수 있으나, **서버는 아직 클라이언트로부터 아무 메시지를 받지 못해 클라이언트가 서버의 sequence number를 정상적으로 수신했는지 알 수 없다.** 이때 서버는 이 단계에서 전송된 ACK를 수신함으로써 비로소 클라이언트가 서버의 sequence number를 정상적으로 수신했음을 알게 된다.


#### 2) connection 종료(4-way handshake)

\- 센더와 리시버 사이 통신이 더 이상 이뤄지지 않는 경우 구축된 connection을 종료시켜야 한다. TCP의 connection 종료는 다음 단계를 통해 이루어진다.

(1) 클라이언트가 서버를 향해 FIN 메시지(connetion 종료를 요청하는 메시지)를 전송한다.

(2) FIN 메시지를 수신한 서버는 그에 대한 ACK를 전송하고(이로써 서버는 CLOSE-WAIT 상태가 된다), 뒤이어 클라이언트를 향하여 FIN 메시지를 전송한다.

- 3-way handshake에서는 단 한 번의 SYN/ACK의 전송만으로 ACK와 서버 측 sequence number 전송이 가능했으나 connection 종료에서는 서버가 FIN과 ACK를 따로 전송하기 때문에, 3-way handshake보다 전송하는 메시지 개수가 하나 더 늘어난다. 그래서 connection 종료를 4-way handshake라고 한다.

(3) ACK 메시지 수신 후(이때 FIN-WAIT-2 상태가 된다) FIN 메시지를 수신한 클라이언트는 그에 대한 ACK를 전송하고 TIME-WAIT 상태가 된다.

- 클라이언트는 자신이 보낸 FIN 메시지에 대한 ACK를 수신하고 그에 대한 ACK를 전송한 이후에도 바로 connection 종료 상태가 되지 않고 **TIME-WAIT 상태가 되었다 일정 시간이 경과한 후 그 다음에 비로소 connection 종료 상태가 된다.** 이는, 만약 클라이언트가 전송한 ACK가 도중에 유실되어 서버가 이를 수신하지 못해 **다시 FIN 메시지를 보낼 경우 그에 대한 ACK를 다시 보내줘야 하기 때문**이다.



### 5. TCP의 congestion control

