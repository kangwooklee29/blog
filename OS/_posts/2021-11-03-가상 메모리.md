### 1. demand paging

\- 대부분의 OS는 프로세스를 page 단위로 관리하여 가상메모리에 있는 page들을 요청이 있을 때에 메인 메모리로 옮겨와 이를 사용한다. 이처럼 가상메모리의 page를 필요할 때 메인 메모리로 옮겨와 사용하는 방식을 demand paging이라 한다.

\- demand paging을 사용하면 다음 이점이 있다.

(1) 중요도가 높은 page를 메인 메모리로 옮겨와 사용하므로, I/O에 소모되는 시간을 절약할 수 있다.

(2) 중요도가 떨어지는 page를 디스크로 내리므로, 메모리를 효율적으로 사용할 수 있다.

(3) 멀티 프로그래밍 환경에서 많은 사용자에게 빠른 응답속도로 결과를 내보낼 수 있다.


### 2. page fault

\- page table에서 어떤 엔트리가 invalid 상태로 돼있다면, 이는 그 부분에 해당하는 page가 (1)프로세스에서 사용되지 않는 영역이거나 (2)메인 메모리에 없고 디스크의 가상 메모리에 저장돼있음을 뜻한다. 당장 CPU에서 메인 메모리로 직접 접근할 수 없는 영역임은 분명하므로, 이러한 영역으로의 호출이 발생하면 프로세스는 trap을 발생시킨다(이 trap을 page fault라 한다). 

\- page fault 발생 시 OS는 다음과 같은 순서를 따라 이를 처리한다.

(1) 그 영역이 프로세스에서 사용되지 않는 영역인지, 접근권한이 없는 것인지 등을 확인한다. 이에 해당한다면 프로세스를 강제 종료하고, 그게 아니고 그 영역이 디스크의 가상 메모리에 저장돼있는 것이라면 다음 단계로 넘어간다.

(2) 메인 메모리에 빈 frame이 있는지 확인한다. 빈 frame이 없다면 메인 메모리의 page 중 어느 하나를 디스크로 옮긴다. (이를 swap out이라 하며, 이러한 일련의 swap in - swap out 과정을 page replacement라 한다. 여기서 어떤 page를 선택할 것인지가 메모리 효율과 관련해서 매우 중요한 문제가 된다. 예를 들어 호출되는 빈도가 높은 page를 자꾸 디스크로 옮기게 된다면, 디스크로 옮겨진 그 page를 계속 메인 메모리로 옮겨오는 과정에서 어마어마한 overhead가 발생하게 된다.) 

(3) 호출된 page를 디스크에서 메인 메모리의 빈 frame으로 옮겨온다(이를 swap in이라 한다).

(4) 옮겨오는 작업이 끝나면, page table의 그 page에 해당하는 엔트리를 valid 상태로 바꾸고 다음 명령어를 처리한다.


### 3. page replaecement

replace할 page를 선택하는 데 있어 전체적인 page-fault rate를 최소화 하도록 page를 선택하는 것이 컴퓨터 시스템의 효율에 있어 중요한 문제가 된다. 다음은 page-fault rate를 최소화하기 위한 방법으로서 제시된 replacement 알고리즘들이다.


#### 1) Belady's optimal algorithm

\- page들이 앞으로 어떤 순서대로 요청될지를 처음부터 끝까지 다 알고 있다고 전제할 때, '**현재 메모리에 있는 page 중 가장 나중에 참조될 page를 swap out 한다**'라는 알고리즘을 쓸 수 있으며 이 알고리즘이 page-fault rate를 최소로 하는 알고리즘이다.

\- 실제 컴퓨터 시스템에서 '가장 나중에 참조될 page'는 알 수 없으므로, 이 알고리즘은 비현실적인 상황을 전제로 한 이론상의 알고리즘에 불과하다. 단, replacement 알고리즘 중 이보다 더 빠른 알고리즘은 존재하지 않으므로, replaecement 알고리즘을 논하는 데 있어 이 알고리즘을 하나의 기준으로 생각할 수 있다. (이 알고리즘으로부터, 'replacement 알고리즘에서 가장 중요한 것은 앞으로 어떤 page가 가장 덜 참조될 것인지를 예측하는 것'이라는 힌트를 얻을 수 있다. 실제로 앞으로 논의할 모든 replacement 알고리즘이 여태 참조된 page들의 이력을 통해 각 page들이 앞으로 얼마나 더 참조될지를 유추해보는 알고리즘에 해당한다.)


#### 2) FIFO(first in first out) algorithm

\- '메모리에 swap in된 순서대로 swap out 한다'는 알고리즘이다. 이 알고리즘은 특이하게도, 메모리의 frame 수가 적을 때보다 frame 수가 많을 때 page-fault rate가 더 높을 때가 있다. 이러한 현상을 'FIFO abnomaly'라 한다.

#### 3) LRU(least recently used) algorithm

\- '가장 오래 전에 참조된 page를 swap out 한다'는 알고리즘이다. '과거에 참조된 page일수록 앞으로 다시 참조될 가능성이 낮고, 최근에 참조된 page일수록 앞으로 다시 참조될 가능성이 높다'는 추측에 기반한 알고리즘이다. 

\- doubly linked list로 구현하면 O(1)로 구현할 수 있다.

#### 4) LFU(least frequently used) algorithm

\- '가장 적게 참조된 page를 swap out 한다'는 알고리즘이다. '여태까지 높은 빈도로 참조된 page일수록 앞으로도 참조될 가능성이 높고, 낮은 빈도로 참조된 page일수록 앞으로도 참조될 가능성이 낮다'는 추측에 기반한 알고리즘이다. 

\- heap으로 구현하면 O(logn)으로 구현할 수 있다.