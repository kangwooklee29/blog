### 1. bounded-buffer 문제

**버퍼의 크기가 유한**하고 동시에 이 버퍼에 데이터를 추가하는 프로세스(생산자)와 가져가는 프로세스(소비자)가 각각 하나 이상 있을 때, 다음 문제가 발생한다.

(1) 생산자 프로세스 둘이 동시에 같은 버퍼 공간에 데이터를 쓰는 문제, 소비자 프로세스 둘이 동시에 같은 버퍼 공간의 데이터를 가져가 이를 조작하는 문제

- 먼저 버퍼 공간에 데이터를 쓰기/가져가기 시작한 프로세스가 데이터를 쓰기 전에 버퍼에 lock을 걸고, 데이터를 다 쓴/가져간 후 unlock하는 식으로 문제를 해결할 수 있다.

- 이의 구현을 위해 필요한 semaphore 변수는 하나(lock/unlock 여부를 표현하는 binary 변수)면 충분하다.

(2) 생산자 프로세스가 데이터를 쓰려고 보니 버퍼가 가득 차있는 문제, 소비자 프로세스가 데이터를 가져가려고 보니 버퍼가 비어있는 문제

- 빈 버퍼 공간이 생기거나 채워진 버퍼 공간이 하나씩 생길 때까지 각 프로세스가 대기하도록 하여 문제를 해결할 수 있다.

- 이의 구현을 위해 필요한 semaphore 변수는 두 개(채워진 버퍼공간의 수를 기록하는 변수, 빈 버퍼공간의 수를 기록하는 변수)가 필요하다. 


### 2. readers-writers 문제

\- 하나의 DB에서 동시에 하나 이상의 프로세스가 데이터를 읽으려 하고(reader 프로세스) 또 동시에 하나 이상의 프로세스가 데이터를 쓰려 할 때(writer 프로세스), reader 프로세스는 둘 이상이어도 문제가 발생하지 않지만, **reader 프로세스가 읽는 중 writer 프로세스가 데이터를 쓰려 하거나 writer 프로세스가 둘 이상이면 문제가 발생한다.**

\- 이 문제는 (1)reader 프로세스가 데이터를 읽는 중에는 DB에 lock을 걸어 writer 프로세스가 데이터를 쓰지 못하게 하고, (2)reader 프로세스가 둘 이상인 경우를 위해 현재 데이터를 읽는 중인 reader 프로세스의 개수를 세서, 그 수가 0이 되기 전까지 writer 프로세스가 데이터를 쓰지 못하게 하는 식으로 해결할 수 있다.

\- 이의 구현을 위해 필요한 semaphore 변수는 세 개(DB의 lock/unlock 여부를 표현하는 binary 변수, reader 프로세스의 수를 기록하는 변수, reader 프로세스의 수를 기록하는 변수를 조작할 때 다른 프로세스가 이 변수를 조작하는 것을 막는 lock/unlock 여부를 표현하는 bianry 변수)가 필요하다.

\- 그런데 이러한 방식으로 문제를 해결하면, reader 프로세스가 끊임없이 들어와 writer 프로세스는 영원히 데이터를 쓸 수 없는 starvation 문제가 발생할 수 있다. 이 경우 reader 프로세스가 일정 수 이상 데이터를 읽었으면 그 다음에 writer 프로세스가 데이터를 다 쓸 때까지 대기했다가 그 다음으로 대기중이던 reader 프로세스가 데이터를 읽게 하는 식으로 문제를 해결할 수 있다.

### 3. dining-philosophers 문제

\- 원형 테이블에 5명의 철학자가 앉아 있고, 각 철학자의 왼쪽과 오른쪽에는 각각 젓가락이 한 짝씩 있어 테이블 위에 젓가락이 총 5개 있다고 하자. 각 철학자는 양쪽의 젓가락을 하나씩 들어 음식을 먹거나 음식을 먹지 않고 가만히 있을 수 있는데, 젓가락 두 짝이 있어야 음식을 먹을 수 있는데 젓가락은 공유자원이므로 한 철학자가 젓가락을 가져갔다면 다른 철학자는 그 철학자가 젓가락을 다시 내려놓을 때까지 음식을 먹을 수 없다. 

\- 각 철학자가 음식을 먹기 전에 왼쪽 젓가락과 오른쪽 젓가락을 집어들었을 때 lock을 걸고 음식을 먹은 후에는 unlock하는 알고리즘을 생각해보자. 이 알고리즘은 예를 들어 모든 철학자가 왼쪽 젓가락을 집어든 상황에서는 어떤 철학자도 영원히 음식을 먹을 수 없다는 deadlock 문제가 발생한다.

\- 다음 방식으로 문제를 해결할 수 있다.

(1) 철학자가 젓가락 개수보다 적게 테이블에 앉게 하기

(2) 양쪽 젓가락을 모두 집을 수 있는 상황일 때에만 젓가락을 집게 하기

(3) 철학자를 시계 방향 또는 반시계 방향으로 순서대로 번호를 붙인다 할 때, 홀수번 철학자는 왼쪽 젓가락부터 집게 하고 짝수번 철학자는 오른쪽 젓가락부터 집게 하기

\- 위 알고리즘 중 '양쪽 젓가락을 모두 집을 수 있는 상황일 때에만 젓가락을 집게 하기' 알고리즘은 다음 방식으로 구현할 수 있다.

(1) 각 철학자의 상태를 먹는 중 / 먹는 차례를 대기 중 / 그 밖의 다른 일을 하는 중 셋으로 구분한다.

(2) i번 철학자가 대기 중 상태가 되었을 때, 그 양쪽 철학자가 모두 먹는 중이 아니라면 i번 철학자에게 젓가락을 집을 권한을 부여한다. 양쪽 철학자 중 어느 하나가 먹는 중이라면 젓가락을 집을 권한을 부여하지 않고 대기한다.

(3) i번 철학자가 음식을 먹은 후에는 i-1번 및 i+1번 철학자가 젓가락을 집을 수 있는 상황인지를 검토하고, 집을 수 있는 상황이라면 젓가락을 집을 권한을 부여한다.

\- 이의 구현을 위해서는 공유변수인 각 철학자의 상태 변수, 그리고 그 상태 변수의 lock/unlock 여부를 결정하는 binary 변수, 그리고 각 철학자가 젓가락 집을 권한이 있는지를 저장하는 binary 배열 변수가 필요하다. 



### 4. monitor

\- semaphore를 이용한 구현은 (1)코딩이 어렵고, (2)정확히 작동하는지 확인이 어렵고 (3)코딩할 때 실수하기 쉬운 데 반해 실수했을 때 치명적인 문제가 나타날 수 있다는 단점이 있다. 이는 lock/unlock을 semaphore형 멤버 변수를 직접 조작하는 방식으로 구현하기 때문으로, class 등을 사용하여 캡슐화하여 구현할 경우 이 문제를 해결할 수 있다. (이때 사용되는 자료형을 흔히 monitor라 한다.)

\- monitor는 lock/unlock 변수를 사용하는 대신, wait()와 signal() 메서드를 가져 이 메서드를 통해서만 값을 변경할 수 있는 condition 변수를 각 프로세스에게 할당하여 process sync 문제를 해결한다. 예를 들어, 어떤 프로세스가 critical section으로 진입하고자 하는 상황이라면, 일단 그 프로세스의 condition 변수의 wait() 메서드를 호출한다. 이때 그 프로세스는 다른 프로세스에서 그 프로세스의 condition 변수의 signal() 메서드를 호출해줄 때까지 suspend 되어 있다가, signal() 메서드 호출이 일어난다면 그때 깨어나 critical section으로 진입한다.