### 1. deadlock 발생 조건

(1) 자원을 한 순간에 한 프로세스만이 사용 가능(mutual exclusion)

(2) 프로세스가 점유하고 있는 자원은 다른 프로세스가 강제로 빼앗을 수 없음(no preemption)

(3) 어떤 프로세스가 수개의 자원을 동시에 점유해야 작업을 처리할 수 있는데 그 중 일부 자원만 점유하고 있다 할 때, 나머지 자원을 얻을 때까지 점유 중인 자원을 계속 점유하면서 무한 대기함(hold and wait)

(4) '자원 -> 자원을 점유하는 프로세스 -> 프로세스가 요청하는 자원' 순으로 방향그래프를 구성했을 때 그 방향그래프에 사이클이 존재함(circular wait)

\- 이 조건은 자원-프로세스 간의 점유-요청 관계의 **현재 상태**에 관한 조건이므로, 자원-프로세스 간의 점유-요청 관계에 관한 특정 상태가 주어졌을 때 이 상태에 deadlock이 존재하는지 아닌지는 결국 그 상태를 방향그래프로 표현했을 때 **사이클이 존재하는지 아닌지를 검토**함으로써 판별하게 된다.

\- 한 종류의 자원에 오로지 하나의 인스턴스만이 존재한다면, 현재상태에 사이클이 존재한다면 이는 반드시 현재상태가 deadlock임을 뜻한다. 그러나 한 종류의 자원에 둘 이상의 인스턴스가 존재한다면, 그 자원이 속한 사이클보다 그 자원이 가진 인스턴스가 더 많다면 그 상태가 반드시 deadlock인 것은 아니다.


### 2. deadlock을 처리하는 방법

\- 상기한 네 조건이 모두 충족될 때 deadlock이 발생하므로, 어느 하나를 제거하면 deadlock이 해소된다.


#### 1) 현재 시스템의 자원-프로세스의 특성을 deadlock 발생 조건과 다르도록 설정(deadlock prevention)

(1) no preemption 조건 변경

- 자원을 프로세스가 점유하고 있더라도 다른 프로세스가 이를 요청하면 즉시 양도한다.

- CPU나 메모리 같이 점유를 뺏기기 전 상태를 저장해두었다가 다시 점유할 기회가 왔을 때 이를 복구하기 쉬운 매체에서 사용하는 방법.

(2) hold and wait 조건 변경

- 둘 이상의 자원이 필요한데 어느 하나를 즉시 점유할 수 없다면, 점유했던 모든 자원을 즉시 반납하는 방법

- 각 프로세스가 필요할 자원을 모두 미리 요청하는 방법

(3) circular wait 조건 변경

- **각 자원별로 할당 순서를 정해, 프로세스가 오직 그 순서대로 자원을 얻게 되었을 때에만 자원을 할당**

\- deadlock prevention 방식으로 deadlock을 피하면, deadlock을 피할 수는 있으나 overhead가 커지고 starvation 문제가 발생할 수 있다는 등의 문제가 있다.

#### 2) 현재 가용 자원이 충분히 풍부해서 프로세스에 자원을 할당해도 deadlock이 절대 발생하지 않을 경우에만 자원을 할당(deadlock avoidance)

\- 이 방법은, 프로세스가 작업을 다 처리할 때까지 요청할 자원의 총량은 알 수 있지만 현재 자원 요청 직후 그 다음으로 추가로 얼만큼의 자원을 요청할지는 알 수 없는 상황을 가정한다. 따라서, 현재 자원의 요청이 있을 때 그 요청을 처리할 만큼의 자원이 충분히 있다 하더라도 곧바로 이를 할당하지는 않고, **그 프로세스가 작업을 다 처리할 때까지 요청할 자원의 총량만큼 자원이 충분히 있을 때에만 현재 요청에 따라 자원을 할당**한다. (이를 banker's algorithm이라 한다.)

\- 이 방법은 '바로 다음 번 요청으로 deadlock이 생길 수 있다'는 식으로 항상 최악의 경우를 가정하기 때문에, deadlock이 생기지 않을 확률이 높은 상황이라 하더라도 조금만 가능성이 있어도 자원을 할당하지 않는 방법이어서 비효율적인 측면이 있다고 볼 수 있다.

#### 3) 일단 수행하되, deadlock이 발생한 듯 보이면 그때 복구(deadlock detection and recovery)

\- 일단 수행하되, 시스템 수행이 느려지는 등 deadlock이 발생한 듯 보이면 그때 deadlock 발생 여부를 검사하여(자원의 인스턴스가 하나면 사이클 검사 방법으로, 둘 이상이면 banker's algorithm과 유사한 방법으로 deadlock 발생 여부를 검사한다) deadlock이 발생했다면 관련된 프로세스를 모두/하나씩 종료시키거나 deadlock이 사라질 때까지 프로세스가 가진 자원을 빼앗아 보되 이로 인해 발생할 overhead를 최소로 할 프로세스의 자원을 빼앗는 식으로 문제를 해결하는 방법이다.

\- 프로세스가 가진 자원을 빼앗는 식으로 recovery를 하면, 자원을 빼앗긴 프로세스가 다시 자원을 얻거나 한번 빼앗긴 후 다시는 자원을 얻지 못하는 문제(starvation)가 있을 수 있다. 이 경우, 프로세스가 자원을 뺏는 패턴을 변경하거나 프로세스가 자원을 빼앗긴 횟수를 세는 변수를 따로 설정해 한 프로세스만 자원을 뺏기는 것을 피하도록 하여 문제를 해결할 수 있다.


#### 4) 그냥 놔두기(deadlock ignorance)

\- deadlock은 발생하는 경우가 매우 드문 데 반해 위에 언급된 방법들은 매우 큰 overhead를 요하는 방법이기에, unix를 포함하여 현재 쓰이는 대부분의 OS는 deadlock에 대해 별다른 조치를 취하지 않으며 deadlock 발생 시 사용자가 직접 일일이 프로세스를 종료시켜 문제를 해결하게 하고 있다.