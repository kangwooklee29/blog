### 1. 개요

\- 크게 CPU, 메모리, I/O 장치 셋으로 나눌 수 있다. (디스크는 파일을 열어 내용을 불러와 메모리에 올린다는 측면에서 입력장치로 볼 수도 있고, 반대로 CPU에 의해 처리된 결과를 전달받아 파일의 형태로 저장한다는 측면에서 출력장치로 볼 수도 있다.)

\- I/O 장치의 모든 정보가 곧바로 컴퓨터의 메인 메모리와 CPU로 전달되는 것은 아니고, 각각 그 장치를 직접 통제하는 device controller와 local buffer를 갖는다.



### 2. 메인 메모리의 프로그램의 I/O 장치 사용

\- 메인 메모리에 있는 사용자 프로그램은 직접 I/O 장치를 사용할 수 없으며, 메인 메모리의 커널을 통해서만 I/O 장치에 접근할 수 있다. 구체적으로, 사용자 프로그램은 I/O 장치를 사용하려는 경우 CPU에 interrupt를 요청하여 커널을 호출하며 _(이처럼 사용자 프로그램이 CPU를 통해 커널을 호출하는 것을 system call이라 한다)_ 이때 CPU의 mode bit가 커널 모드로 변경된다 _(사용자 프로그램이 CPU를 사용하는 동안에는 mode bit는 사용자 모드로 설정되어 있으며, 이때 사용자 프로그램이 I/O 장치로 직접 접근을 시도하면 exception으로 처리된다)_. 

\- 호출되어 CPU를 점유하게 된 커널은 CPU가 I/O 장치에 사용자 프로그램의 요청을 전달하게 한다. 


### 3. I/O 장치의 CPU 사용

\- device controller는 I/O 장치의 입/출력을 수행하며, 수행이 완료되면 CPU에 interrupt를 요청하여 완료 사실을 알린다. 이때 커널이 다시 CPU로 호출되어 이 정보를 받아 처리하여 다시 사용자 프로그램에 전달한다.

### 4. interrupt

\- interrupt 또는 trap _(=system call, exception의 통칭으로, 다른 말로 sofware interrupt라고도 한다)_ 이 발생하여 CPU로 전달되면 CPU는 **현재 수행하고 있던 연산을 즉각 종료**하고 각 interrupt 또는 trap의 유형에 따라 그에 맞는 적절한 interrupt 처리 루틴을 수행한다. 

\- interrupt 처리 루틴은 **커널의 함수**로서, 그 코드의 메모리 주소를 갖고 있는 것을 interrupt vector라 하며 이들 interrupt vector들은 CPU의 한 부분인 interrupt vector table에 저장돼 있다.

### 5. DMA(Direct Memory Access) controller

\- I/O 장치의 interrupt가 발생할 때마다 이를 모두 CPU에 전달하게 하면, interrupt 빈도가 너무 잦을 경우 CPU가 제대로 연산을 수행 못하는 일이 일어날 수 있다. 이를 방지하기 위하여 보통은 I/O 장치의 device controller의 수행이 종료되면 그 결과가 local buffer에 저장되고, 전달할 양이 적당한 수준에 이르렀을 때가 되어서 비로소 interrupt를 요청한다. 이때 DMA controller가 메인 메모리에 직접 접근하여 local buffeer의 정보를 메인 메모리로 복사한다.


#### * 타이머

\- 사용자 프로그램 하나가 지나치게 오래 CPU를 점유하는 경우를 방지하기 위하여 보통은 사용자 프로그램이 CPU를 점유하기 시작할 때 타이머를 설정하며, 설정된 시간이 경과하면 타이머는 CPU로 interrupt를 요청하여 현재 CPU를 점유 중인 사용자 프로그램의 연산을 즉각 종료하게 한다.