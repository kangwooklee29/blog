### 1. race condition

\- 특정 메모리 주소에 있는 변수 하나의 값을 서로 다른 프로세스 또는 서로 다른 CPU(multiprocessor system일 경우)가 동시에 조작하는 경우(한쪽에서는 값을 증가시키고 다른 쪽에서는 값을 감소시키는 경우 등)가 있을 수 있다. 이처럼 한 메모리 주소의 값을 서로 다른 주체가 변경하고자 하는 상황을 race condition이라 한다.

\- 예를 들어 프로세스 A가 한 변수의 값을 가져가 이를 증가시키는 연산을 하고 결과값을 저장하러 왔는데, 그 사이에 프로세스 B가 그 변수의 값을 감소시키는 연산을 하고 그 결과값을 먼저 저장해놓은 경우가 있을 수 있다. 이 경우 프로세스 A가 더 나중에 그 주소의 변수값을 변경했으므로, 프로세스 B가 그 변수의 값을 감소시킨 사실은 메모리 기록에서 사라지게 된다. 이처럼 race condition에서는 synchronize가 중요한 문제가 된다.


### 2. race condition에 대한 커널의 대처법

\- race condition은 커널과 관련해서 흔히 일어나는 상황이므로(일반적인 사용자 프로세스는 각자 메모리의 독립된 영역만을 사용하므로 race condition은 일반적인 사용자 프로세스에서 흔히 일어나는 상황은 아니다), 커널과 관련된 race condition을 유형별로 알아보고 그에 대한 대처법을 먼저 확인할 수 있다.

#### 1) 커널의 CPU 점유 중 interrupt가 발생한 경우

\- 커널의 CPU 점유 중 interrupt가 발생하면 커널은 연산을 중단하고 interrupt 처리 루틴을 수행해야 하는데, interrupt 발생 전 값을 변경하고자 한 변수가 있어 **그 값을 읽어온 상태일 때 interrupt가 발생**했고 interrupt 처리 루틴 수행 과정에서 먼저 그 값을 변경하는 경우가 있을 수 있다. 

\- 이 경우, interrupt가 발생했다 하더라도 **일단 하던 연산을 계속 수행하게 한 후 그 연산이 끝나면 그제야 interrupt 처리 루틴을 수행**하게 하는 식으로 race condition을 해결할 수 있다.

#### 2) 프로세스가 I/O 장치 접근 위해 커널을 호출한 상황에서 timer interrupt가 발생한 경우

\- 프로세스 A가 I/O 장치 접근을 위해 커널을 호출한 상황에서 timer interrupt가 발생한 경우에, 그 다음 프로세스인 프로세스 B도 수행 도중 I/O 장치 접근을 위해 커널을 호출해 두 프로세스에서 모두 커널을 호출했고 또 커널이 호출된 각 상황에서 동일한 변수의 값을 변경하는 경우가 있을 수 있다.

\- 이 경우, interrupt가 발생했다 하더라도 **커널 모드에 있다면 일단 하던 연산을 계속 수행하게 한 후 그 연산이 끝나면 그제야 context switch**를 하게 하는 식으로 race condition을 해결할 수 있다.

#### 3) multiprocessor 환경에서 공유 메모리 상의 커널 영역의 변수를 사용하는 경우

\- 이 경우는 interrupt가 발생하는 상황이 아니므로 'interrupt가 발생했다 하더라도 일단 하던 연산을 계속 수행하게 한다'는 식으로는 문제를 해결할 수 없다.

\- 다음 두 방법으로 race condition을 해결할 수 있다.

(1) 커널을 사용하는 CPU는 한 번에 하나만 허용한다.

(2) 커널이 shared memory에 접근할 때마다 그 데이터에 lock을 걸어 다른 CPU가 그 데이터에 접근한다 하더라도 값을 변경할 수 없게 한다.



### 3. critical-section problem을 프로그램적으로 해결하기 위한 조건

\- 프로세스가 공유 데이터를 사용하는 경우, 그 프로세스의 코드 중에는 공유 데이터에 접근하는 코드가 있기 마련이다(이를 critical section이라 한다). 현재 수행하는 프로세스 코드가 critical section에 진입할 때, 프로그램적으로 공유 데이터에 lock을 걸어 도중에 interrupt가 일어난다 하더라도 현재 프로세스가 lock을 건 공유 데이터는 사용 못하게 하는 식으로 race condition을 해결할 수 있다(프로그램적 해결).

\- critical-section problem을 해결하는 프로그램이 갖추어야 할 조건은 다음과 같다.

(1) 한 프로세스가 critical section 부분을 수행 중이라면 다른 모든 프로세스들은 각자 자신의 critical section에 들어가면 안된다(mutual exclusion).

(2) 모든 프로세스가 critical section을 수행하고 있지 않다면, critical section에 들어가고자 하는 프로세스는 critical section으로 들어갈 수 있어야 한다(progress).

(3) 어떤 프로세스가 critical section 부분을 수행하겠다고 요청을 했다면 그 프로세스는 (다른 프로세스들만 critical section을 수행하여 그 프로세스는 critical section을 수행하지 못하는) starvation에 빠지지 않고 결국 그 critical section을 수행할 수 있어야 한다(bounded waiting).


### 4. critical-section problem을 프로그램적으로 해결하는 알고리즘들

#### 1) '현재 critical section 진입 권한을 갖는 프로세스의 ID'를 변수로 저장하기

\- 현재 critical section 진입 권한을 갖는 프로세스 ID를 변수로 저장하고, (1)**그 ID와 일치하는 프로세스만 critical section에의 진입을 허용**하고 그 외의 프로세스는 critical section 앞에서 무한 대기 (2)프로세스는 critical section 수행 후 즉시 그 진입권을 다른 프로세스에 양도하게 하는 알고리즘을 쓸 수 있다.

\- 이 알고리즘은 mutual exclusion은 충족하나 progress 조건을 충족하지 않는다. 또, critical section 진입권을 양도받은 프로세스는 critical section을 수행하는 경우가 그리 많지 않은데 양도한 프로세스는 critical section을 수행해야 하는 코드가 많다면 이처럼 'critical section 수행 즉시 진입권 양도' 방식은 전체적으로 비효율적일 수 있다.

#### 2) '각 프로세스가 현재 critical section으로 진입을 필요로 하는지'를 저장하는 플래그 배열을 사용하기

(1) 각 프로세스가 현재 critical section으로 진입을 필요로 하는지 여부를 저장하는 플래그 배열을 만든다.

(2) critical section으로 진입을 필요로 하는 상황이 되면, 그 프로세스의 플래그 값을 true로 변경한다.

(3) 다른 프로세스들의 플래그 값이 true인 동안은 critical section 앞에서 무한 대기하고, 모든 플래그 값이 false가 되었을 때 critical section에 진입한다.

(4) critical section을 수행한 후에는 플래그 값을 false로 변경한다.

\- 이 알고리즘도 mutual exclusion은 충족하나 progress 조건을 충족하지 않는다. 


#### 3) 플래그 배열과 critical section 진입권 갖는 프로세스 ID를 저장하는 변수 동시에 사용하기(Peterson's algorithm)


(1) 각 프로세스가 현재 critical section으로 진입을 필요로 하는지 여부를 저장하는 플래그 배열을 만든다.

(2) critical section으로 진입을 필요로 하는 상황이 되면 그 프로세스의 플래그 값을 true로 변경하고, **critical section 진입권을 갖는 프로세스 ID를 현재 프로세스가 아니라 그 다음 프로세스로 설정**한다.

(3) **현재 critical section 진입권을 갖는 프로세스의 플래그 값이 true인 동안은 critical section 앞에서 무한 대기**하고, 플래그 값이 false인 프로세스가 진입권을 갖게 되었을 때 critical section에 진입한다.

(4) critical section을 수행한 후에는 플래그 값을 false로 변경한다.

\- critical section 진입권을 자꾸 다른 프로세스에 양도하다 보면 결국 플래그 값이 false인 프로세스에게 진입권이 양도되는 순간이 반드시 오므로, 이 알고리즘은 progress 조건을 충족한다. 단, 대기하는 코드를 while문을 사용해 구현하면 대기하는 시간 동안 외부 변화 여부와 무관하게 쉬지 않고 조건문 충족 여부를 연산하는 'busy waiting' 문제가 있다. 이 경우, 대기 상태에 들어간 프로세스들을 blocked 상태로 설정하고 blocked 상태인 프로세스들을 큐에 넣어 대기하게 하여 문제를 해결할 수 있다. (그런데 blocked 상태에서 wakeup 상태로 전환하는 데는 overhead가 커질 수 있으므로, critical section이 짧은 경우라면 그냥 busy waiting이 더 효율적일 수도 있다.)

\- 또, critical section 진입 전 단계의 코드를 (a)플래그값을 true로 변경하고 (b)critical section 진입권을 양도하는 식으로 일일이 구현하면 둘 중 어느 한 작업만 겨우 막 수행했는데 거기서 갑자기 interrupt가 발생해 불완전한 상태에서 다른 프로세스가 critical section으로 들어오는 문제가 발생할 수 있다. 다만 이 경우는 일련의 과정을 atomic하게 구현하는 코드와(이때 사용하는 자료형을 흔히 semaphore라 한다) 이를 지원하는 하드웨어를 사용하면 간단하게 해결할 수 있다.


### 5. process synchronization 고전 3문제


#### 1) bounded-buffer 문제

**버퍼의 크기가 유한**하고 동시에 이 버퍼에 데이터를 추가하는 프로세스(생산자)와 가져가는 프로세스(소비자)가 각각 하나 이상 있을 때, 다음 문제가 발생한다.

(1) 생산자 프로세스 둘이 동시에 같은 버퍼 공간에 데이터를 쓰는 문제, 소비자 프로세스 둘이 동시에 같은 버퍼 공간의 데이터를 가져가 이를 조작하는 문제

- 먼저 버퍼 공간에 데이터를 쓰기/가져가기 시작한 프로세스가 데이터를 쓰기 전에 버퍼에 lock을 걸고, 데이터를 다 쓴/가져간 후 unlock하는 식으로 문제를 해결할 수 있다.

- 이의 구현을 위해 필요한 semaphore 변수는 하나(lock/unlock 여부를 표현하는 binary 변수)면 충분하다.

(2) 생산자 프로세스가 데이터를 쓰려고 보니 버퍼가 가득 차있는 문제, 소비자 프로세스가 데이터를 가져가려고 보니 버퍼가 비어있는 문제

- 빈 버퍼 공간이 생기거나 채워진 버퍼 공간이 하나씩 생길 때까지 각 프로세스가 대기하도록 하여 문제를 해결할 수 있다.

- 이의 구현을 위해 필요한 semaphore 변수는 두 개(채워진 버퍼공간의 수를 기록하는 변수, 빈 버퍼공간의 수를 기록하는 변수)가 필요하다. 


#### 2) readers-writers 문제

\- 하나의 DB에서 동시에 하나 이상의 프로세스가 데이터를 읽으려 하고(reader 프로세스) 또 동시에 하나 이상의 프로세스가 데이터를 쓰려 할 때(writer 프로세스), reader 프로세스는 둘 이상이어도 문제가 발생하지 않지만, **reader 프로세스가 읽는 중 writer 프로세스가 데이터를 쓰려 하거나 writer 프로세스가 둘 이상이면 문제가 발생한다.**

\- 이 문제는 (1)reader 프로세스가 데이터를 읽는 중에는 DB에 lock을 걸어 writer 프로세스가 데이터를 쓰지 못하게 하고, (2)reader 프로세스가 둘 이상인 경우를 위해 현재 데이터를 읽는 중인 reader 프로세스의 개수를 세서, 그 수가 0이 되기 전까지 writer 프로세스가 데이터를 쓰지 못하게 하는 식으로 해결할 수 있다.

\- 이의 구현을 위해 필요한 semaphore 변수는 세 개(DB의 lock/unlock 여부를 표현하는 binary 변수, reader 프로세스의 수를 기록하는 변수, reader 프로세스의 수를 기록하는 변수를 조작할 때 다른 프로세스가 이 변수를 조작하는 것을 막는 lock/unlock 여부를 표현하는 bianry 변수)가 필요하다.

\- 그런데 이러한 방식으로 문제를 해결하면, reader 프로세스가 끊임없이 들어와 writer 프로세스는 영원히 데이터를 쓸 수 없는 starvation 문제가 발생할 수 있다. 이 경우 reader 프로세스가 일정 수 이상 데이터를 읽었으면 그 다음에 writer 프로세스가 데이터를 다 쓸 때까지 대기했다가 그 다음으로 대기중이던 reader 프로세스가 데이터를 읽게 하는 식으로 문제를 해결할 수 있다.

#### 3) dining-philosophers 문제

\- 원형 테이블에 5명의 철학자가 앉아 있고, 각 철학자의 왼쪽과 오른쪽에는 각각 젓가락이 한 짝씩 있어 테이블 위에 젓가락이 총 5개 있다고 하자. 각 철학자는 양쪽의 젓가락을 하나씩 들어 음식을 먹거나 음식을 먹지 않고 가만히 있을 수 있는데, 젓가락 두 짝이 있어야 음식을 먹을 수 있는데 젓가락은 공유자원이므로 한 철학자가 젓가락을 가져갔다면 다른 철학자는 그 철학자가 젓가락을 다시 내려놓을 때까지 음식을 먹을 수 없다. 

\- 각 철학자가 음식을 먹기 전에 왼쪽 젓가락과 오른쪽 젓가락을 집어들었을 때 lock을 걸고 음식을 먹은 후에는 unlock하는 알고리즘을 생각해보자. 이 알고리즘은 예를 들어 모든 철학자가 왼쪽 젓가락을 집어든 상황에서는 어떤 철학자도 영원히 음식을 먹을 수 없다는 deadlock 문제가 발생한다.

\- 다음 방식으로 문제를 해결할 수 있다.

(1) 철학자가 젓가락 개수보다 적게 테이블에 앉게 하기

(2) 양쪽 젓가락을 모두 집을 수 있는 상황일 때에만 젓가락을 집게 하기

(3) 철학자를 시계 방향 또는 반시계 방향으로 순서대로 번호를 붙인다 할 때, 홀수번 철학자는 왼쪽 젓가락부터 집게 하고 짝수번 철학자는 오른쪽 젓가락부터 집게 하기

\- 위 알고리즘 중 '양쪽 젓가락을 모두 집을 수 있는 상황일 때에만 젓가락을 집게 하기' 알고리즘은 다음 방식으로 구현할 수 있다.

(1) 각 철학자의 상태를 먹는 중 / 먹는 차례를 대기 중 / 그 밖의 다른 일을 하는 중 셋으로 구분한다.

(2) i번 철학자가 대기 중 상태가 되었을 때, 그 양쪽 철학자가 모두 먹는 중이 아니라면 i번 철학자에게 젓가락을 집을 권한을 부여한다. 양쪽 철학자 중 어느 하나가 먹는 중이라면 젓가락을 집을 권한을 부여하지 않고 대기한다.

(3) i번 철학자가 음식을 먹은 후에는 i-1번 및 i+1번 철학자가 젓가락을 집을 수 있는 상황인지를 검토하고, 집을 수 있는 상황이라면 젓가락을 집을 권한을 부여한다.

\- 이의 구현을 위해서는 공유변수인 각 철학자의 상태 변수, 그리고 그 상태 변수의 lock/unlock 여부를 결정하는 binary 변수, 그리고 각 철학자가 젓가락 집을 권한이 있는지를 저장하는 binary 배열 변수가 필요하다. 



### 6. monitor

\- semaphore를 이용한 구현은 (1)코딩이 어렵고, (2)정확히 작동하는지 확인이 어렵고 (3)코딩할 때 실수하기 쉬운 데 반해 실수했을 때 치명적인 문제가 나타날 수 있다는 단점이 있다. 이는 lock/unlock을 semaphore형 멤버 변수를 직접 조작하는 방식으로 구현하기 때문으로, class 등을 사용하여 캡슐화하여 구현할 경우 이 문제를 해결할 수 있다. (이때 사용되는 자료형을 흔히 monitor라 한다.)

\- monitor는 lock/unlock 변수를 사용하는 대신, wait()와 signal() 연산이 지원돼 이 연산들을 통해서만 값을 변경할 수 있는 condition 변수를 사용하여 process sync 문제를 해결한다. 예를 들어, 어떤 프로세스가 critical section으로 진입하고자 하는 상황이라면, 일단 그 프로세스가 critical section으로 진입할 수 있는 상황인지를 보고 아니라면 condition 변수의 wait() 메서드를 호출한다. 이때 그 프로세스는 다른 프로세스에서 그 프로세스의 condition 변수의 signal() 메서드를 호출해줄 때까지 suspend 되어 있다가, signal() 메서드 호출이 일어난다면 그때 깨어나 critical section으로 진입한다.