### 1. address binding 방법의 종류

#### 1) compile time binding

\- 코드를 컴파일을 할 때 address binding을 같이 하는 경우가 있다. 하나의 컴퓨터에 하나의 프로그램만 동작하게 하는 경우에 사용할 수 있는 방법으로, 멀티프로그래밍이 지원되는 현재 대부분의 컴퓨터에서는 쓰이지 않는 바인딩 방법이다.

#### 2) load time binding

\- 프로세스가 메모리에 처음 로드될 때 바인딩을 하는 방법

#### 3) execution time binding(=run time binding)

\- 프로세스는 메모리에 처음 로드된 뒤에도 swapper에 의해 swap space로 옮겨졌다가 나중에 다시 프로세스를 실행시킬 필요가 생겨 그때 메모리로 돌아올 수 있는데, 그때마다 바인딩을 새로 할 수밖에 없다. 이처럼 프로세스가 실행될 때 바인딩을 하는 것을 execution time binding(=run time binding)이라 한다.


### 2. MMU의 작동 과정

1) CPU가 현재 메모리에서 불러오고자 하는 데이터의 logical address를 MMU로 전달한다.

2) MMU는 일단 그 주소가 현재 CPU를 점유하는 프로세스의 메모리 점유 범위(이를 저장하고 있는 레지스터를 limit register라 한다)를 벗어나는지를 확인한다.

- 벗어나는 경우: trap을 발생시킨다.

- 벗어나지 않는 경우: 전달받은 logical address에 현재 MMU에 저장된 그 프로세스의 시작 부분의 물리적 주소값(이를 저장하고 있는 레지스터를 relocation register 또는 base register라 한다)을 더해 메모리 상의 그 위치의 데이터를 가져온다.


### 3. 프로세스를 메모리에 로드하는 방법 유형

#### 1) overlay

\- 프로그램의 코드에 의해, 프로세스의 전체 데이터 중 현재 당장 필요한 부분만을 메모리에 로드하는 방법. 과거 메모리가 너무 작아 프로세스 전체를 메모리에 모두 로드하는 것이 불가능할 때, 프로그래머가 코딩을 할 때 프로세스를 쪼개 '지금 이 부분만 메모리에 로드한다' 하는 명령어를 써가며 프로그램을 만드는 경우가 많았다. 이처럼 프로그래밍 때 프로그래머가 직접 프로세스의 일부만을 메모리에 로드하도록 해 이를 통해 프로세스를 메모리에 로드하는 것을 overlay라 한다.

\- 프로그래머가 직접 메모리에 상주할 부분과 overlay할 부분을 나누어 설계해야 했기에 구현 난이도가 아주 높은 방법이다.


#### 2) dynamic load

\- 프로세스의 전체 데이터를 일시에 메모리에 로드하지 않고, 현재 당장 필요한 부분만을 메모리에 로드하는 방법으로, 이 역시 프로그램 코드를 통해 프로세스의 전체 데이터 중 일부를 메모리에 로드하는 방법이다. overlay와 유사하나 좀더 나중의 방법으로서, 코드 길이는 방대하나 사용 빈도는 다소 떨어지는 예외처리 같은 코드를 사용할 때 흔히 쓰였다.

#### 3) swapping

\- swapper를 사용하여, 우선순위가 낮은 프로세스를 swap out하고 우선순위가 높아진 프로세스를 swap in 하는 식으로 메모리를 관리하는 방법.

\- 보통 디스크에서 메모리로 파일 내용을 전송할 때 걸리는 시간은 데이터의 길이보다는 데이터의 위치를 탐색하는 데 걸리는 시간이 훨씬 더 오래 걸리지만(디스크 헤드가 움직이는 시간이 그만큼 길기 때문), paging이 없는 경우 swap in - swap out 과정에서 전송되는 데이터 양은 디스크에서 파일 내용을 전송하는 경우보다 훨씬 많으므로 paging 없는 swapping의 swap 시간은 swap space에서 메모리로 전송되는 프로세스 데이터의 길이에 비례한다.


#### * dynamic linking

\- 코드를 컴파일하면 메모리 이곳저곳에 컴파일된 결과 파일들이 흩어져 있을 수 있는데(특히 코드가 외부 라이브러리를 사용하는 경우), 이처럼 흩어져 있는 컴파일 결과들을 하나로 묶어 하나의 실행파일로 만드는 것을 linking이라 한다.

\- 프로그램의 코드에 남이 만든 라이브러리 코드가 포함된 것을 static linking이라 한다. static linking은 라이브러리를 많이 사용할수록 실행파일 크기가 커지는데, 어차피 남이 만든 라이브러리를 사용하는데 이를 프로그램을 만들 때마다 일일이 프로그램 코드에 포함시켜 컴파일을 하게 된다면 여러 프로세스가 동일한 코드를 중복해서 갖고 있게 된다. 이러한 프로세스들이 모두 동시에 메모리에 로드되게 된다면 이는 큰 메모리 자원 낭비가 될 것이다.

\- 반대로, 라이브러리가 프로그램의 코드에 직접 포함되지 않고 별도의 독립된 파일로 존재하여 프로그램이 메모리에 로드된 후 필요할 때에만 이 파일에 접근해서 필요한 코드를 실행하게 한다면, 여러 프로세스가 같은 라이브러리를 사용한다 하더라도 메모리 낭비가 일어나지 않을 것이다. 이를 'linking이 프로세스의 실행 시에만 일어난다' 하여 dynamic linking이라 한다.

\- Linux의 .so 파일, Window의 .dll 파일이 dynamic link를 지원하기 위해 존재하는 파일이다.



### 4. 메모리 주소 할당 방법

#### 1) 프로세스를 쪼개지 않고 메모리 상의 연속적인 영역에 할당

(1) 고정분할

- 메모리를 정해진 크기로 나누었다가 프로세스가 로드될 때 나뉜 크기보다 작은 프로세스를 그 영역에 할당하는 방법이다.

- 로드된 프로세스의 크기가 너무 커서 나뉜 메모리 영역에 할당되지 못한 경우 그 영역을 '외부 조각'이라 한다. 반대로, 나뉜 메모리 영역이 너무 커서 그 영역 내에 프로세스가 할당되었음에도 채워지지 않은 영역이 있는 경우 그 영역을 '내부 조각'이라 한다.


(2) 가변분할

- 특별히 메모리를 정해진 크기로 나누거나 하지는 않고 그냥 프로세스를 메모리의 빈 영역에 되도록 빈틈 없이 차례대로 할당하는 방법이다. 메모리를 정해진 크기로 나누거나 하지 않고 되도록 빈틈 없이 프로세스를 할당하므로, 고정분할 방식의 '내부 조각' 같은 개념은 존재하지 않는다. (그러나 외부 조각 개념은 있다. 먼저 로드된 프로세스가 종료될 경우 그 메모리 영역은 텅 빈 공간이 되지만, 그 다음으로 로드된 프로세스의 크기가 그 공간보다 크다면 그 프로세스는 그 영역에 할당될 수 없다. 이때 이렇게 빈 공간으로 남는 영역이 가변분할에서의 외부 조각이다.)

- 프로세스를 할당할 영역을 찾는 알고리즘은 일단 모두 메모리의 앞 주소부터 차례대로 훑기 시작한다는 점이 같다. 이때 (1)적절한 공간이 나타나면 곧바로 그곳에 할당하는 알고리즘(first fit), (2)전체 빈 공간 개수를 모두 비교하여, 그 프로세스가 들어갈 수 있으면서 크기가 가장 작은 공간에 할당하는 알고리즘(best fit), (3)크기가 가장 큰 공간에 프로세스를 할당하는 알고리즘(worst fit) 세 가지가 있다. 둘 이상의 프로세스를 할당한다 할 때, worst fit보다 first fit이나 best fit 알고리즘이 속도, memory utilization 측면에서 더 효과적이라는 사실이 알려져 있다.

- 프로세스가 로드됐다 종료되는 일이 반복되면, 전체 외부조각의 크기를 합하면 메모리에 여유 공간이 충분한데도 불구하고 외부조각들이 서로 떨어져 있기 때문에 더 이상 메모리에 프로세스가 로드되지 못하는 경우가 발생할 수 있다. 이를 외부 단편화(external fragmentation)라 한다. 이를 해결하려면 메모리에 로드돼 있는 프로세스들에 할당된 메모리 영역을 한 군데로 몰아 외부조각의 크기를 커지게 해야 하는데(이를 compaction이라 한다) 굉장히 큰 overhead가 발생하여(프로세스를 최소한으로 이동하는 알고리즘을 생각할 수 있지만 이 역시 실제 구현에는 곤란한 점이 많다) 이 방식을 사용하는 데는 어려운 점이 있다.



#### 2) 프로세스를 여러 조각으로 나누어 각 조각을 메모리 상의 빈 공간 구석구석에 할당

(1) paging


(2) segmentation

(3) paging-segmentation