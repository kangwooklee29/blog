### 1. 쿼리를 대문자로 써야 하는 이유

\- 오라클의 경우 쿼리 입력 시 그 쿼리가 예전에 수행된 적 있는지를 탐색하는데, 이전에 같은 내용의 쿼리가 입력된 적 있어도 대소문자가 다르면 다른 쿼리가 입력된 것으로 보므로 캐시를 참조하지 않고 매번 새로 탐색을 수행하게 된다. 이는 비효율적이므로, 일반적으로 쿼리를 쓸 때 키워드와 속성명을 대문자 아니면 소문자로 일관적으로 쓰도록 하는 규칙을 정해두고 쿼리를 쓰게 된다. 그 외에도 대소문자에 관하여 일관된 규칙으로 쿼리를 쓰는 것이 가독성이 더 좋고 유지보수가 용이하다는 등의 장점이 있다.


### 2. SELECT 쿼리의 기본형태

```sql
SELECT table1.field1, table1.field2 FROM table1 {WHERE field1 < 10 ORDER BY field1, field2 DESC LIMIT 10}
```

\- 기본적으로 SELECT + 속성명 + FROM 테이블명의 형태를 갖고 있으며, 해당 테이블의 해당 속성명의 모든 값이 위에서 아래로 죽 나열된 항목들을 가져오게 된다.


### 3. 속성명 쓰기

#### 1) DISTINCT field1

\- field1의 값이 중복된 경우, 중복된 항목을 제거한다.

#### 2) field1 AS 'field2'

\- 테이블에서 field1 속성의 값들을 가져오지만, 그 값의 속성명을 field2로 지정하여 가져온다.

#### 3) 그룹함수(COUNT, SUM, MAX, MIN, ...)

\- 그룹함수는 보통 다른 속성명을 쓰지 않고 단독으로 쓰지만, 그룹화 쿼리(GROUP BY)를 쓰는 경우 다른 속성명과 함께 쓰이기도 한다.

(a) COUNT(field1)

\- field1 속성의 값들을 만약 가져온다면 가져오게 될 항목의 개수를 세서 **그 개수를 그 열의 유일한 항목이 갖는 값으로 하는 열을 만들어 가져온다.**

\- field1 속성의 값 중 그 값이 null인 항목이 있다면 그 항목은 제외하고 개수를 센다. 단, 인자로 속성명이 아니라 **\*을 넣는다면 값이 null인 항목을 포함**해 개수를 센다.


(b) SUM(field1), MAX(field1), MIN(field1)

\- field1 속성의 값들을 모두 합한 값/최댓값/최솟값을 그 열의 유일한 항목이 갖는 값으로 하는 열을 만들어 가져온다.


#### 4) CASE WHEN ... THEN ... END

```sql
CASE 
    WHEN field1 % 3 = 0 THEN '나머지 0' 
    WHEN field1 % 3 = 1 THEN '나머지 1'
    ELSE '나머지 2'
END
```

\- 각 항목이 조건식을 충족할 경우 **그에 해당하는 값(THEN 뒤에 쓰인 값)을 그 항목이 그 열에서 갖는 값으로 하는 열을 만들어** 가져온다.

#### 5) IF(field1%2 = 0, '짝수', '홀수')

\- 각 항목이 조건식을 충족하는 경우와 충족하지 않는 경우로 구분하여 각각 그에 해당하는 값을 그 항목이 그 열에서 갖는 값으로 하는 열을 만들어 가져온다.

#### 6) DATE_FORMAT(field1, '%Y-%m-%d %H:%i:%s')

\- 각 항목의 field1 값을 DATE_FORMAT 함수의 인자로 넣어 마찬가지로 인자로 전달된 **포맷 문자열에 대응되는 값**을 그 항목이 그 열에서 갖는 값으로 하는 열을 만들어 가져온다.



### 4. 조건식 WHERE

#### 1) IS NULL, IS NOT NULL


#### 2) field1 BETWEEN 1 AND 10

\- field1의 값이 1과 10 사이 정수인 항목을 가져온다.

#### 3) field1 IN (1, 3, 5, 7, 9) / field1 NOT IN (1, 3, 5, 7, 9)

\- field1의 값이 1, 3, 5, 7, 9 중 어느 하나인 항목(또는 1, 3, 5, 7, 9가 아닌 항목)을 가져온다.

\- 괄호 안에는 위와 같이 쉼표로 구분된 정수/문자열 대신 (SELECT field2 FROM table2)와 같은 SQL 쿼리가 들어갈 수도 있다.

#### 4) filed1 LIKE '%오%'

\- field1의 값이 '오'를 포함하는 문자열인 항목을 가져온다.



### 5. GROUP BY field1

```sql
SELECT field1, count(field1) AS cnt FROM table1 WHERE field1 >= 3 GROUP BY field1 HAVING cnt >= 2 ORDER BY field1 
```

\- 그룹함수와 함께 쓰며, 각 항목이 그 속성명의 각 값과 그 값에 해당하는 그룹함수 값으로 이루어지는 **새로운 테이블을 만들어 가져온다.** 예를 들어, table1의 각 항목들이 field1 속성에 대하여 각각 값이 1, 1, 3, 3, 5, 5라 할 때, 위 쿼리는 다음 테이블을 가져온다.

| field1 | cnt |
|---|---|
| 3 | 2 |
| 5 | 2 |



### 6. SELECT table1.field1 FROM table1 JOIN table2 ON table1.field1 = table2.field2

\- table1의 각 항목의 field1 값이 table2의 어떤 항목의 field2 값과 일치할 때 **그 두 항목을 결합한 항목들로 이루어진 테이블을 만들고** 그 테이블에서 지정된 속성명의 모든 값이 위에서 아래로 죽 나열된 항목들을 가져온다. _(한편, ON 부분을 생략하면 table1의 모든 항목에 table2의 모든 항목을 각각 결합한 항목들로 이루어진 새로운 테이블이 만들어진다.)_

- table1의 어떤 항목의 field1값과 일치하는 **table2의 field2값이 없다면** 그 항목은 가져오지 않는다. 단, **LEFT JOIN**의 경우 몇몇 속성명을 NULL로 남겨두는 한이 있더라도 **table1의 모든 항목**을 가져온다.

- table1의 한 항목의 field1값과 일치하는 **table2의 field2값이 여러 개라면** 그 항목을 여러 개 만들고 일치하는 table2의 모든 항목을 각 항목에 모두 결합하여 가져온다.

- table2의 어떤 항목의 field2값과 일치하는 table1의 field1값이 없다면 그 항목은 가져오지 않는다. 단, **RIGHT JOIN**의 경우 몇몇 속성명을 NULL로 남겨두는 한이 있더라도 **table2의 모든 항목**을 가져온다.

\- table1과 table2의 속성명이 일치하는 경우가 있더라도 일단 **두 속성명 모두 join된 결과 테이블에 존재**한다. 이때 각 속성명은 그 속성이 원래 있던 테이블명을 속성명 앞에 붙여 지칭한다.

\- FROM과 JOIN 뒤의 테이블명 뒤에 AS로 축약된 이름을 붙여 속성명이나 조건식에서 축약된 이름으로 그 테이블을 참조할 수 있다.