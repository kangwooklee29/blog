### 1. 디스크의 구조

\- 하드웨어로서 하나의 디스크는 여러 개의 원판(platter)가 하나의 축(spindle)으로 이어져 있으며, 각 원판에는 원판에 기록된 데이터를 읽을 수 있는 헤드가 하나씩 붙어 있다. 

\- 원판에는 원판에 저장되는 데이터들을 구분하는 균일한 크기의 최소단위인 섹터가 여럿 모여 원판을 이룬다. 축으로부터 거리가 동일한 섹터들을 '같은 트랙에 있다'라고 하며, 서로 다른 원판에 있으나 반지름이 동일한 트랙들을 함께 묶어 하나의 '실린더'로 지칭한다. 파일을 읽거나 쓰려 하는 경우, 디스크의 원판들이 회전하며, 하나의 arm에 같이 붙어있는 헤드들은 안쪽에서 바깥으로(또는 바깥에서 안쪽으로) **1차원적으로** 움직이며 각 원판의 섹터에 저장된 정보를 읽거나 쓰게 된다.

\- 섹터 하나는 OS가 디스크에 저장된 데이터를 인식하는 논리적 최소 단위인 블록 하나에 대응된다. 보통 블록/섹터 하나에 저장되는 데이터의 크기는 512B인데, 섹터는 데이터 정보 외에도 그 섹터의 오류 발생 여부를 검사할 수 있는 ECC(error-correcting code)와 그 섹터의 위치 정보 등이 데이터 영역의 head 또는 tail 영역에 추가로 저장돼 있다.

\- OS가 인식하는 데이터 블록은 0번부터 1씩 증가하는 정수 번호가 매겨져 있는데, 디스크의 섹터는 그 위치를 정확히 서술하기 위해서는 그 섹터가 위치한 원판, 트랙번호 등의 정보가 추가로 필요하다. (섹터는 데이터 블록에 대응되나 데이터 블록의 번호와 같은 번호값을 갖는 것은 아니다.)

\- 컴퓨터 시스템의 부팅 절차는 다음과 같다.

(1) 컴퓨터 시스템에 전원이 들어오면, **가장 먼저 ROM**에 있는 small bootstrap loader가 실행된다.

(2) small bootstrap loader는 디스크의 가장 바깥 실린더의 **0번 섹터**(이곳을 boot block이라 한다)의 데이터를 읽어온다. 

(3) boot block에 저장돼 있던 full bootstrap loader는 file system을 탐색하여 그 디스크 안에서 **OS 파일들을 찾아** 이를 메모리에 로드한다.


### 2. 디스크 스케줄링 알고리즘

같은 컴퓨터 시스템이라 하더라도 partition마다 파일이 저장되는 방식이 다를 수 있고, 따라서 각 partition별 디스크 스케줄링 알고리즘 또한 달라질 수 있다.

#### 1) FCFS(first come first service)

#### 2) SSTF(shortest seek time first)

\- 현재 디스크로 요청된 섹터들의 큐에서, 현재 헤드가 위치한 트랙과 가장 가까운 트랙에 있는 섹터를 찾아 그걸 최우선으로 처리하는 알고리즘이다.

\- 큐에 요청이 들어온 순서대로 처리하는 게 아니라 큐에 있는 섹터 중 현재 헤드 위치와 가장 가까운 섹터를 최우선적으로 처리하는 알고리즘이므로, starvation 문제가 발생할 수 있다.

#### 3) scan, c(circular)-scan, n-scan, look, c-look

\- scan은 **엘리베이터**처럼, 헤드가 **한쪽 끝에서 다른 쪽 끝으로 이동할 때까지 방향을 바꾸지 않고 계속 이동**하며 각 위치에 있는 섹터를 우선적으로 처리하며 이동을 반복하는 알고리즘이다. 여러 방식으로 개선된 알고리즘이 있으며, 디스크 I/O가 많은 시스템에서 효율성이 높아 현재 대부분의 디스크가 이와 유사한 방식으로 디스크 스케줄링을 처리한다.

\- 요청이 들어온 섹터의 위치가 양쪽 끝에 가깝냐 가운데쪽에 가깝냐에 따라 요청에서 처리까지 걸리는 시간이 달라진다. 양쪽 끝에 가까운 섹터는 설령 헤드가 지나간 직후 요청이 들어온다 하더라도 오래 지나지 않아 금방 요청이 처리되어 아주 interactive하나, 가운데쪽 섹터는 헤드가 막 지나간 뒤 요청이 들어온다면 한 주기를 기다린 뒤에야 비로소 요청이 처리된다.

\- c-scan: 안쪽에서 바깥쪽 끝까지 헤드가 이동해 헤드가 다시 안쪽으로 움직일 때, 이런 상황에서는 요청을 처리하지 않는 알고리즘. 헤드가 지나간 직후 요청이 들어온 섹터는 어떤 트랙에 있든 한 주기 기다려야 비로소 처리를 받을 수 있다는 점에서 요청-처리까지 걸리는 시간이 모든 트랙에게 공평하다.

\- n-scan: 헤드가 안쪽에서 바깥쪽 끝으로 이동을 시작하기 전에 들어온 요청만을 이동하면서 처리하고, 이동 시작 후 들어온 요청은 아직 헤드가 그 위치를 지나지 않았어도 다음 주기가 돌아오기 전까지는 처리하지 않는 알고리즘.

\- look, c-look: 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동할 때까지 방향을 바꾸지 않고 계속 이동한다는 점은 scan, c-scan과 동일하나, 만약 여기서 저쪽 끝으로 헤드가 더 이동하더라도 현재 들어온 요청 중에 그쪽으로 들어온 요청이 없다면 그쪽 방향으로의 이동을 중단하고 방향을 바꿔 이동하는 알고리즘.



### 3. RAID(rebundant array of independent disks)

\- 하나의 파일의 내용을 여러 디스크에 나눠 저장하거나, 같은 내용을 여러 디스크에 반복해 저장하는 등 여러 디스크를 동시에 사용하여 디스크 I/O 효율 향상 또는 신뢰성 확보 등의 목적을 충족시키는 것을 RAID라 한다.