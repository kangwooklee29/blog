### 1. 준지도학습

\- 훈련데이터 중 일부에만 레이블이 있을 때, 레이블이 있는 데이터와 없는 데이터를 모두 활용해 ML 모델을 훈련시키는 기법을 준지도학습(semi-supervised learning, SSL)이라 한다.

\- 여러 준지도학습 방식이 제시되고 있으며, 모두 전체 데이터셋 중 레이블이 있는 데이터의 비율이 극히 적은 상황에서도 모든 데이터에 레이블이 있는 데이터셋에 크게 뒤지지 않는 오차율을 보인다.

#### 1) \\(\pi\\)-model(ICLR 2017)

\- 훈련데이터를 신경망의 입력데이터로 넣을 때 미니배치 안에 레이블이 있는 데이터와 레이블이 없는 데이터가 적절히 섞이도록 미니배치를 구성하며, 각 미니배치는 다음 방식으로 loss를 계산한다.

- labeled data: 그 입력에 대한 레이블을 기준으로 loss를 계산한다.

- unlabled data: (1)먼저 그 입력 데이터에 대해 Gaussian 방식으로 노이즈를 발생시키고(stochastic augmentation), 같은 방식으로 그 입력 데이터를 하나 증진시킨다. (2)이 두 데이터를 모두 신경망에 입력으로 넣어 얻은 두 결과 벡터 간 차이(squared difference)를 기준으로 loss를 계산한다. (즉, 신경망이 '원본이 같은 데이터에 대해 같은 결과값'을 갖도록 학습을 진행한다.)

- 한 미니배치의 loss값은 미니배치에 속한 각 입력 데이터에 대해 위 방식으로 계산한 모든 loss를 합산하여 계산한다. 단, 학습 epoch가 증가할수록 unlabeled data에 대해 계산한 loss의 가중치를 점점 높여나가면서 loss를 계산한다.

\- 이처럼 augmentation을 거친 데이터를 입력으로 추론한 결과가 원본 데이터를 입력으로 추론한 결과가 일치하도록 신경망을 업데이트 하는 학습 방식을 consistent training 또는 consistency regularization이라 한다.


#### 2) temporal ensemble(ICLR 2017)

\- 기존 \\(\pi\\)-model의 경우 unlabled data의 loss를 계산할 때 원본 데이터와 이로부터 증진된 하나의 데이터만으로 loss를 계산한다. temporal ensemble은 '이런 방식으로는 노이즈가 클 수밖에 없다'라는 관점에서, unlabeled data의 loss를 계산할 때 증진된 하나의 데이터만을 기준으로 loss를 계산하는 게 아니라 매 epoch 때마다 얻은 결과 벡터와 '여태까지 각 epoch마다 나온 결과 벡터들을 합산한 평균 벡터' 두 벡터를 기준으로 loss를 계산한다. 

- 각 epoch마다 나온 결과 벡터끼리 합산해 평균을 계산할 때에는 새 epoch의 결과 벡터와 과거 얻은 결과 벡터 사이 합산 비율을 임의로 조정할 수 있다. 

\- 이와 같은 방식으로 loss를 계산하면 기존 \\(\pi\\)-model에 비해 다음 이점이 있다.

(1) 기존 \\(\pi\\)-model은 매 epoch의 각 입력 데이터마다 신경망 추론을 2회씩 진행하나, 이 방식은 신경망 추론을 1회만 진행한다.

(2) 기존 \\(\pi\\)-model은 loss를 계산할 때 입력 데이터와 단 하나의 증진된 데이터만으로 loss를 계산해 노이즈가 크게 발생할 수 있으나, 이 방식은 여러 epoch에 걸쳐 누적된 결과 벡터를 기준으로 loss를 계산하므로 노이즈가 적게 발생할 수밖에 없다.

\- 다만 이 방식은 각 입력 데이터에 대한 결과 벡터를 매 epoch가 끝난 후에도 지워지지 않고 메모리에 남겨둬야 하므로 그만큼(결과벡터의 크기 \\(\times\\) 입력 데이터의 개수)의 메모리가 추가로 필요하다.


#### 3) MixMatch(NIPS 2019)

\- 이 방식은 다음 순서대로 loss를 계산한다.

(1) labeled data와 unlabeled data에 대해 각각 augmentation을 수행한다.

- 이때 unlabeled data의 경우 한 데이터 당 특정 횟수만큼 augmentation을 수행하고 각 결과 데이터를 신경망의 입력으로 해서 얻은 결과 벡터들의 평균을 그 데이터의 label로 지정한다. (이를 pseudo-label이라 한다. pseudo-label을 구하기 위해 얻은 결과 벡터에 sharpen 연산을 수행하여 이 벡터의 pseudo-label을 보다 선명하게 지정한다.)

(2) labeled, unlabeled data를 가리지 않고 augmentation을 수행한 모든 데이터를 하나의 집합(이하 \\(\mathcal{W}\\))에 담는다.

(3) \\(\mathcal{W}\\)을 기준으로 labeled data와 unlabeled data에 대해 각각 MixUp 연산을 수행해 얻은 새로운 데이터셋을 기준으로, 그 데이터셋에서 입력 데이터를 꺼내 신경망으로 추론한 결과 벡터와 레이블 벡터를 비교해 각 데이터셋의 loss를 계산하고 이를 통해 그 epoch에서의 신경망을 업데이트한다.

- MixUp 연산이란, 두 개의 데이터셋 집합이 있을 때 각 데이터셋 집합에서 데이터를 하나씩 꺼내와 두 데이터끼리 선형결합 연산을 해 얻은 결과 데이터를 연산 결과로 내놓는 집합연산이다. 

(4) 이 과정을 매 epoch마다 반복한다.



#### 4) FixMatch(NIPS 2020)

\- 이 방식은 다음 순서대로 loss를 계산한다.

(1) 각 unlabeled data마다 한 번은 weak augmentation을 수행한 후 신경망의 입력으로 하고, 또 한 번은 strong augmentation을 수행한 후 신경망의 입력으로 해서 각각 결과 벡터를 얻는다.

- weak augmentation을 수행한 입력은 그 추론 결과 벡터의 성분 중 가장 큰 성분만 남겨둔 벡터를 그 데이터의 pseudo-label로 지정한다.


(2) strong augmentation을 수행한 후 얻은 결과 벡터와 weak augmentation을 수행한 후 얻은 pseudo-label을 비교해 그 데이터의 loss를 계산한다.

(3) labeled data에 대한 loss와 unlabeled에 대한 loss를 합산해 이번 epoch의 최종 loss를 계산하고, 이로써 신경망을 업데이트한 후 다음 epoch로 넘어간다.



### 2. data augmentation

#### 1) AutoAugment(CVPR 2019)

\- 예를 들어 이미지 데이터셋의 경우 CIFAR10은 좌우대칭 data augmentation이 효과적이지만 MNIST는 좌우대칭 data augmentation이 효과적이지 못한데, MNIST의 데이터는 좌우가 대칭이 되면 의미가 달라지는 데이터가 있기 때문이다. 이처럼 데이터셋마다 어떤 data augmentation을 하느냐에 따라 ML 모델의 성능이 달라지는데, AutoAugment는 어떤 데이터셋이 입력으로 주어질 때 그 데이터셋에 어떤 data augmentation을 하면 좋은지를 자동으로 찾는 알고리즘이다.

\- 2019년 개념이 제시되었으나, 현실화하기에는 필요로 하는 계산량이 너무 많아 현실적 적용에는 어려움이 있다.

#### 2) RandAugment(NIPS 2020)

\- AutoAugment의 현실적 적용에 어려움이 있어 이를 개선하기 위해 2020년 제시된 알고리즘으로, 'augmentation의 유형'과 'augmentation의 정도'라는 2개의 매개변수만으로 augmentation을 수행하는 알고리즘이다. 

\- 이를 제시한 논문에 따르면, 데이터셋의 크기가 클수록 augmentation의 정도가 커야 이를 통해 훈련시킨 ML 모델의 성능도 좋아지는 것으로 나타난다.


#### 3) test-time augmentation

\- ML 모델에 입력 데이터를 넣어 추론을 할 때, 입력 데이터 하나만 넣는 게 아니라 그에 대해 augmentation을 수행한 데이터들 또한 신경망에 넣어 얻은 결과들의 평균으로써 그 입력 데이터의 추론 결과를 얻는 것을 test-time augmentation이라 한다.

\- 이런 방식으로 추론 결과를 얻으면 정확도가 향상되고 불확실성이 해소된다는 등의 장점이 있으나, 추론 시간이 배로 늘어난다는 등의 단점이 있다.



### 3. 전이학습

\- 어떤 데이터셋을 잘 추론하는 ML 모델을 만들기 위해 반드시 아무 훈련되지 않은 신경망을 써야 하는 것은 아니며, 특정 데이터셋으로 훈련돼 있는 신경망이라 하더라도 그 신경망을 훈련시킨 데이터셋이 내가 지금 만들고자 하는 ML 모델의 훈련 데이터로 사용하려 했던 데이터셋과 유사하다면 그 신경망의 layer들을 이용하여 내가 풀고자 하는 문제를 푸는 신경망을 구축할 수도 있다. 이처럼 이미 훈련돼 있는 신경망을 이용한 새 신경망을 구축하는 것을 전이학습(transfer learning)이라 한다. 얼핏 느끼기에 대규모로 사전 훈련된 ML 모델을 가져오면 여기 없는 클래스를 학습시키려면 상당한 데이터가 필요할 것 같고 또 상당한 횟수의 epoch을 거쳐 훈련시켜야 할 것처럼 생각할 수 있지만, 실제로는 새로 학습시키고자 하는 클래스 안 데이터가 극단적으로 적은 상황이고 겨우 3-4번 남짓 epoch만 추가로 훈련시켰다 하더라도 매우 잘 학습하는 것을 볼 수 있다.

\- 사전 훈련 데이터셋과 새로 훈련시키는 데이터셋의 분포가 서로 크게 다르면 기대한 만큼의 성능을 얻지 못할 수 있다. 다만 사전 훈련 데이터셋이 충분히 방대하다면 성능이 괜찮게 나오는 경향이 있다.

\- 전이학습에는 크게 다음 두 유형이 있다.

- freezing: 사전 훈련된 신경망을 그대로 가져오고 맨 마지막 layer에만 빈 layer를 추가해, 이 layer만을 새 데이터셋을 통해 훈련시킨다. 이 방식은 새로 훈련시키게 되는 매개변수의 수가 매우 적기 때문에, 예를 들어 사전 훈련된 신경망이 처리하는 클래스 수보다 적은 수의 클래스로 분류하는 문제를 풀고자 할 때 쓰기 좋은 방식이다. 전이학습 후에도 변경되는 매개변수의 수가 크지 않다는 장점이 있다.

- finetuning: 사전 훈련된 신경망을 그대로 가져온 다음, 새 데이터셋을 통해 신경망 전체를 훈련시킨다. 이 방식은 많은 수의 매개변수를 변경하기 때문에, 사전 훈련된 신경망보다 더 많은 수의 클래스로 분류하는 문제를 풀고자 하거나 큰 데이터셋으로 새로 훈련시킴으로써 새 문제를 푸는 데 특화하는 신경망으로 만들고자 할 때 쓰기 좋은 방식이다. 전이학습 후 상당수의 매개변수가 변경되므로 전이학습을 거친 신경망은 전이학습 전 기존 신경망이 풀 수 있었던 문제를 풀기 부적합해진다는 단점이 있다.



### 4. 자기지도학습

\- 레이블이 전혀 없는 훈련데이터만으로 ML 모델을 훈련시키는 기법을 자기지도학습(self-supervised learning)이라 한다. 보통 (1)먼저 문제를 푸는 사람이 임의로 정의한 문제(pretext task)를 푸는 정답을 각 훈련 데이터에 대응되는 레이블로 지정하여 feature extractor 신경망을 학습시키고, (2)이 신경망을 이용해(전이학습) 당초 풀고자 했던 문제를 푼다. 

