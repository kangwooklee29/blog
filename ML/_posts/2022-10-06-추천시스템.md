### 1. 추천엔진

\- 서비스의 규모가 작아 서비스가 제공하는 아이템의 수가 적어 사용자가 한 눈에 모든 아이템을 파악할 수 있다면 추천엔진의 필요가 적다. 그러나 서비스의 규모가 점점 성장해 서비스가 제공하는 아이템의 수도 크게 늘어 사용자가 자신이 필요로 하는 아이템을 찾기 위해 서비스가 제공하는 검색엔진을 사용해야 할 정도 상황이라면 추천엔진의 필요도 커진다. '검색'이라는 활동은 사용자가 서비스 내에서 찾고자 하는 아이템이 무엇인지가 비교적 명확할 때 하는 활동이며, 또 사용자가 적극적이고 능동적으로 이를 서비스 내에서 찾고자 할 의지가 있을 때 하는 활동이다. 그러나 그런 사용자는 전체 사용자 수 대비 매우 적은 편이며, 대부분의 사용자는 검색엔진을 활용하기보다 서비스에 대한 흥미를 잃고 그 서비스 밖으로 관심을 돌리게 된다. 이럴 때 사용자들의 관심을 다시 서비스 안으로 끌어들일 수 있는 좋은 수단이 바로 추천엔진이다. 따라서 추천엔진의 성능은 서비스의 매출 증대에 있어 매우 중요한 역할을 한다고 볼 수 있다.

\- 먼저, 일차적으로 추천엔진을 '사용자가 관심 있어 할 만한 아이템을 자동으로 제공'하는 것으로 정의할 수 있다(알파 제인의 정의). 이 관점에서 볼 때, 추천엔진 개발에서 중요하게 봐야 할 점은 '관심을 어떻게 표현하고 측정해(유사도 측정) 아이템들을 연결하느냐'라고 할 수 있다. 그 다음으로, 궁극적 사업 목표에 주목하여 추천엔진을 '장기적인 영업 목표를 개선할 수 있는 아이템을 자동으로 제공'하는 것으로 정의할 수 있다(디팍 아그라왈의 정의). 이 관점에서 볼 때 추천엔진이 사용자가 단순히 오래 관심을 끄는 아이템을 추천하는 것은 부족하며, 사용자가 보다 영업 주체 측에 더 높은 매출을 불러일으키는 행동을 더 많이 하게 할 만한 아이템을 추천하는 것이 추천엔진의 목표가 된다.


### 2. 추천엔진의 기능

\- 추천엔진은 다음 요소를 고려하여 사용자에게 아이템을 추천할 수 있다.

- 개인화: 사용자 개개인의 서비스 이용 이력을 파악하여, 그 사용자가 관심 있어 할 만한 아이템이 무엇인지를 추려 이를 추천한다. 사용자의 서비스 이용 이력이 적다면 개인에게 특화된 아이템 추천이 어려우나 사용자의 서비스 이력이 늘수록 개인에게 특화된 아이템 추천이 용이해진다.

  - 협업 필터링(collaboartive filtering): 사용자가 구매한 아이템을 구매한 다른 사용자들이 구매한 아이템을 그 사용자에게 추천한다.

  - 분류체계 이용: 사용자가 구매한 아이템이 속하는 분류체계에 속하는 다른 인기 아이템을 그 사용자에게 추천한다.


- 우연한 발견(serendipity): 사용자에게 특화된 아이템 외에, 사용자가 전혀 관심 없을 법한 낯선 아이템 중에도 어떤 아이템은 우연히 사용자의 관심을 끌 수 있다. 

- 새로운 아이템: 여러 사용자가 조회한 아이템이라면 그 아이템이 어떤 사용자가 선호할 아이템인지에 관한 정보가 많이 누적됐을 것이나, 서비스에 추가된지 얼마 되지 않은 아이템은 사용자가 조회한 이력이 적어 어떤 사용자가 선호할 아이템인지 알 수 없다. 이를 고려해, 어떤 사용자가 선호할지에 관한 정보가 부족한 아이템이라 하더라도 사용자에게 추천한다.


\- 추천엔진은 사용자가 서비스를 이용 중일 때뿐 아니라, 사용자가 서비스 사용 중이 아니라 하더라도 사용자의 관심도가 높을 만한 아이템이 새로 나타났다면 사용자의 SMS나 이메일에 관련 정보를 전송한다든지 해서 서비스에서 벗어난 사용자를 다시 서비스로 끌어모으는 마케팅 등에 활용할 수 있다.



### 3. 추천엔진 개발 시 고려할 사항

\- 추천엔진을 ML로 구현하려면 사용자와 아이템을 벡터로 표현해야 하며, 추천엔진의 성능을 높이려면 벡터로 표현할 정보의 양을 늘리기 위하여 사용자와 아이템에 관한 부가 정보들이 필요해진다.

- 아이템 측면의 고려 사항

  - 분류 체계: 아이템의 분류 체계를 만들고 아이템들을 각 분류 체계로 분류한다.

  - 태그: 아이템에 관한 정보를 나타내는 키워드를 추출해 태그를 단다.

- 사용자 측면의 고려 사항

  - 개인 정보: 성별, 연령대, 주거지 등 정보로 분류한다.

  - 아이템 정보: 사용자가 클릭/구매했던 아이템이 속한 분류, 클릭/구매했던 아이템이 없는 분류 등의 정보를 사용자에게 단다.


\- 추천엔진을 ML로 구현했을 때, 예측 목표로서 정확히 무엇을 예측할지를 다르게 설정할 수 있다.

  - 클릭: 사용자가 아이템을 클릭할지 여부를 예측할 수 있다.

  - 구매: 사용자가 아이템을 구매할지 여부를 예측할 수 있다.

  - 사용: 사용자가 아이템을 구매 후 이를 얼마나 이용할지를 예측할 수 있다.

  - 평점: 사용자가 아이템을 구매 후 어떤 평점을 줄지를 예측할 수 있다.


\- 추천엔진 UI 또한 추천엔진의 성능에 영향을 주는 요소일 수 있다. 예를 들어 어떤 아이템을 추천할 때 그것이 사용자의 어떤 요소를 고려한 추천인지를 밝힌 경우와 밝히지 않은 경우를 비교해 보면 사용자에게 고려 요소를 밝힌 추천 시스템이 더 좋은 성능을 보인다. 또 추천하는 아이템들 사이 순서 또한 추천엔진의 성능에 영향을 주며, 개인화에 따른 추천 아이템과 비개인화 추천 아이템의 순서 같은 다양한 요소도 영향을 준다. (추천 아이템이 너무 많다면 사용자들은 굳이 스크롤을 내려 추천 아이템들을 다 살펴 보지 않기 때문에 '순서'라는 요소는 추천엔진에서는 매우 중요하다.) 이와 같은 다양한 요소가 추천엔진의 성능에 영향을 주기 때문에, '어떤 추천 아이템들을 어떤 순서로 구성하는 것이 성능을 최대화하는가' 또한 ML 모델을 통해 예측할 수도 있다.



### 4. 추천 알고리즘 유형

추천 알고리즘의 수는 워낙 많고, 하나만 쓰는 게 아니라 여러 개를 조합하여 쓰는 경우가 많다. 여기서는 대표적인 3가지 유형을 소개한다.

#### 1) 컨텐츠 기반 필터링

\- 각 아이템이 담고 있는 정보를 비교해 각 아이템간 유사도를 파악한 후 유사도가 높은 아이템을 함께 추천한다. (사용자 개개인의 정보를 반영한 개인화된 추천이 아니다.) 추천에 있어 사용자의 성향을 고려하지 않으므로 추천 성능은 아이템의 수에만 영향을 받는데, 사용자를 고려하는 알고리즘의 경우 굉장히 다수 사용자를 고려해야 해 구현이 복잡한 반면 컨텐츠 기반 필터링은 그에 비해 구현이 다소 간단하다.

\- 아이템이 담고 있는 정보 간 유사도를 보다 정확히 파악하기 위해 NLP 관련 기술을 사용하기도 한다. (TF-IDF 등의 방법으로 아이템에 관한 정보를 벡터로 표현하기도 한다.)


#### 2) 협업 필터링

\- 사용자들이 아이템들을 구매/평점 주는 패턴을 파악한 후, 그 사용자가 관심을 보일 만한 패턴을 보이는 아이템을 추천한다. (그 사용자의 소비 패턴에 기반한 추천이므로 개인화된 추천으로 볼 수 있다.) 보다 구체적으로, 그 사용자와 유사한 평점 패턴을 보이는 사용자들이 높은 평점을 매긴 아이템을 추천하는 방법(사용자 기반 협업 필터링), 사용자들이 평점을 주는 패턴이 유사한 아이템들을 한데 묶어 그 사용자에게 이들을 함께 추천하는 방법(아이템 기반 협업 필터링), ML 모델을 통해 그 사용자가 높은 평점을 줄 것 같은 아이템들을 추론해 추천하는 방법이 있다.

- 사용자 기반 협업 필터링: 각 사용자가 총 아이템 개수 크기만한 차원의 벡터를 가지고 있고 이 벡터는 각 성분이 평점인 벡터라고 보고, 사용자끼리 유사도를 계산 후 유사도가 가장 높은 사용자가 높은 평점을 매긴 것을 추천한다. 유사도를 구하는 방법으로는 KNN 알고리즘, 코사인 유사도 등을 쓸 수 있다.

  - 실제로는 대부분의 사용자가 아이템에 평점을 잘 매기지 않으며, 또 서비스의 규모가 커질 경우 사용자의 평점 패턴으로 추천할 아이템을 찾는 데는 계산량이 어마어마하게 늘어나므로 사용자 기반 협업 필터링은 현실적인 사용이 어려운 부분이 있다. (서비스의 규모가 커지는 경우에는 아이템의 수는 증가량이 다소 제한적인 반면 사용자의 규모는 폭발적으로 증가하는 경우가 많다.)


- 아이템 기반 협업 필터링: 각 아이템이 그 아이템에게 평점을 준 사용자 수만한 차원의 벡터를 가지고 있고 이 벡터는 각 성분이 평점인 벡터라고 보고, 아이템끼리 유사도를 계산 후 유사도가 가장 높은 아이템을 추천한다.

  - 사용자 기반 협업 필터링에 비하면 벡터 간 유사도 계산 과정이 훨씬 계산량이 적어 자원을 적게 사용하면서 성능은 뛰어나다. 

\- 협업 필터링은 벡터 간 유사도 측정을 어떤 방식으로 할 것인지가 중요한 문제가 되는데, 보통 코사인 유사도 또는 이를 개선한 피어슨 상관계수(모든 벡터의 성분을 벡터들의 평균을 기준으로 다시 계산한 후 계산)를 사용한다. 

- 예를 들어 특정 사용자가 다른 사용자들보다 평점을 짜게 주는 성향이라면 그 사용자 입장에서는 후한 평점을 매긴 것이라 하더라도 그 사용자가 평점을 준 아이템의 평균 평점이 크게 떨어지는 일이 일어난다. 이 경우 그 사용자가 매긴 평점을 피어슨 상관계수 방법으로 보정한 후 아이템 간 유사도를 측정하면 이와 같은 문제를 해결할 수 있다.

- 코사인 유사도는 유사할수록 1에 가깝고 유사하지 않을수록 0에 가까운 값이 나오는데, 이를 이용해 가장 추천이 유력한 아이템이 가질 만한 벡터 좌표를 포함해 모든 추천 후보 아이템들의 벡터 좌표를 추론할 수 있다. 예를 들어 각 사용자가 갖는 벡터 좌표가 각 사용자가 각 아이템에 대해 매긴 평점으로 정의된다고 할 때, 모든 사용자가 모든 아이템에 대해 평점이 있는 것은 아니기에 일부 벡터 성분은 값을 갖지 않는 경우가 있다. 이때 사용자들끼리 유사도를 계산할 때 그 성분을 제외한 성분들만으로 유사도를 계산한 후, 각 벡터의 성분값이 없는 부분의 성분을 채울 때 그 벡터 성분이 있는 벡터의 성분에 그 벡터와의 유사도를 가중치로서 곱해 더하면 된다.

\- 협업 필터링을 사용하기 위해서는 사용자가 아이템에게 평점을 매긴 내역이 일정 수 이상 돼야 하며, 그러한 내역이 아주 적다면 추천엔진의 성능이 크게 떨어진다(cold start). 이러한 문제를 해결하기 위해 보통은 컨텐츠 기반 필터링, 사용자 행동 기반 추천 등의 방법을 함께 사용한다.

\- 사용자/아이템 기반 협업 필터링의 경우 사용자/아이템 간 유사도는 실시간으로 변하는 것은 아니므로, 유사도를 미리 계산해 두었다가 아이템을 추천해야 할 때 계산해둔 결과를 가져와 빠른 시간 내에 추천 아이템 목록을 만들어낼 수 있다. 그러나 그렇다고 해서 굉장히 오랜 시간이 지났을 때에도 사용자, 아이템 간 유사도가 전혀 변하지 않는다고 할 수는 없으며, 또 새로운 아이템이 추가되고 새로운 평점이 매겨질 때마다 또 달라질 수 있다. 이와 같은 사항을 업데이트하는 것이 중요하며 업데이트 하지 않고 과거 계산했던 유사도를 기준으로 추천하도록 할 경우 성능이 떨어질 수 있다. (유사도 계산 때 오래 전에 매긴 평점 등 정보는 시간이 지나면서 전체 유사도 계산 결과값에 미치는 영향이 줄도록 가중치를 곱한다든가 하는 방법을 통해 시간 정보를 반영할 수 있다.)

\- ML 기반 협업 필터링의 경우 모델이 예측한 평점을 실제 사용자가 매긴 평점과 비교하는 식으로 추천엔진의 성능을 평가하는 게 가능하지만, 사용자/아이템 기반 협업 필터링의 경우 예측된 유사도와 실제 사용자가 생각하는 유사도를 비교하는 것은 불가능해 이와 같은 방식의 성능 평가는 불가능하다. 다만, 추천엔진이 특정 상황에 대한 추천 아이템 목록을 만들게 한 후 실제 사용자가 그와 같은 상황에서 그 목록에 있는 아이템을 클릭/구매했는지 같은 정보를 토대로 성능을 평가해볼 수 있다.


#### 3) 사용자 행동 기반 추천

\- 사용자가 특정 아이템을 클릭/구매했을 때 그 아이템과 유사한 아이템을 추천한다. (어떤 아이템을 추천할 것인지가 사용자 행동에 기반하므로 개인화된 추천이다.) 이에 기반한 추천엔진은 구현이 비교적 매우 간단하나 그에 비해 성능은 다소 괜찮은 편이다.

\- 사용자가 아이템을 클릭/구매할 때마다 이를 묶은 데이터쌍을 만든 후, 이러한 데이터를 ML 모델의 학습 데이터로 학습시켜 사용자에게 아이템을 추천해야 할 때마다 ML 모델을 통해 '이 사용자가 아이템들을 클릭/구매할 확률'을 각각 추론하게 한 후 확률이 높게 나오는 아이템들을 추천하는 방법이 있다. 이러한 방식은 성능이 뛰어난 편이지만, 구현이 다소 복잡하고 자원 사용량도 굉장히 많다는 단점이 있다.

- ML 모델의 학습 데이터를 구축할 때에는 단순히 클릭/구매뿐 아니라 사용시간, 평점까지 종합해 학습 데이터로 활용할 수 있다. 다만 이와 같은 복합적 정보를 모두 활용하기 위해서는 데이터 수집을 위한 인프라가 필요하며, 또 수집된 대량의 데이터를 다루기 위한 데이터 관련 인프라가 필요하다.



### 5. 추천 알고리즘의 발전사

#### 1) 아이템 기반 협업 필터링

\- 2001년 아마존이 아이템 기반 협업 필터링을 처음 발표했는데, '아이템 추천을 기술적 지식을 통해 더 효과적으로 할 수 있다'라는 개념이 사실상 처음 제시된 셈이었기에 큰 화제가 됐다.


#### 2) 넷플릭스 프라이즈

\- 넷플릭스는 2006년부터 자사 회원들의 시청기록 데이터를 제공하여 자사의 추천엔진을 개선하는 것을 목표로 하는 공개 컨테스트를 3년간 개최했는데, 여태까지의 데이터 업계에는 이처럼 방대한 데이터를 기반으로 여러 알고리즘을 비교할 기회가 없었기 때문에 굉장한 화제가 되었다. 이 3년간의 컨테스트를 통해 추천엔진 분야는 급격히 발전하게 되었고, '방대한 데이터를 기반으로 여러 알고리즘을 비교한다'라는 아이디어는 Kaggle 같은 ML 컨테스트 플랫폼이 등장하는 계기가 되었다.

\- 넷플릭스 프라이즈의 우승팀은 여러 알고리즘을 조합한 앙상블 알고리즘으로 우승했는데(우승팀의 구성원들은 처음에는 각각 다른 팀에서 다른 알고리즘으로 준비했으나 시간이 지나면서 서로 알고리즘을 조합하면 성능이 나아진다는 것을 발견하고 함께 모여 앙상블 알고리즘으로 발전시켰다 한다), 그 중에서 협업 필터링에 ML 모델을 통한 추론을 적용했으며 여기서 큰 행렬의 연산량을 크게 줄이는 SVD를 활용해 큰 효과를 얻었다. 이후 이 부분에 대해 많은 발전이 이루어지게 되었다. (다만 실제 추천 결과를 내는 데는 다소 오랜 시간이 걸려 넷플릭스는 실제 이 알고리즘을 자사 추천엔진에 채용하지 못했다.)

- 앙상블 알고리즘의 하나로서, 각 알고리즘으로 각각 따로 추천 결과를 얻고 그 추천 결과들을 종합해 가장 빈도가 높은 결과를 전체 알고리즘의 최종 결과로 하는 방법이 있다. 이러한 방식은 정확도는 높은 편이지만 하나의 추론을 얻기 위해 수개의 알고리즘을 모두 계산해야 하기 때문에 자원 사용량이 크다는 단점이 있다.

#### 3) 아마존 DSSTNE

\- 2016년경부터 추천 알고리즘에 있어 적극적으로 딥러닝을 도입하는 추세가 나타나기 시작했고, 아마존은 2016년 자사의 추천 알고리즘을 오픈소스로 공개했다가 2017년부터는 SageMaker 등 입력 데이터만 주면 그에 대한 추천 결과를 출력하는 클라우드 서비스를 시작하기 시작했다. 이는 개별 업체들이 직접 추천 시스템을 구축하지 않고 클라우드 서비스를 사용하는 것만으로 좋은 추천 시스템을 구현할 수 있어 업계 차원에서 한 단계 발전한 것으로 볼 수 있다.


### 6. 추천엔진의 기본적인 구조

#### 1) 사용자가 서비스에 접속했을 때 출력 페이지 보여주기

(1) 사용자가 과거 서비스를 이용한 이력을 조회해 사용자가 높은 관심을 보일 추천 유닛 후보군을 만든다.

(2) 만들어진 추천 유닛 후보군 사이 순위를 매긴다.

(3) 순위가 높은 추천 유닛 후보들로 출력 페이지를 구성해 사용자에게 보여준다.


#### 2) 특정 추천 유닛 안에 담을 추천 아이템들 구성하기


(1) 그 추천 유닛의 유형에 따라, 입력으로 받은 사용자 또는 아이템의 정보를 이용해 사용자가 높은 관심을 보일 추천 아이템 후보군을 만든다.

(2) 만들어진 추천 아이템 후보군 사이 순위를 매긴다.

(3) 순위가 높은 추천 아이템 후보들을 그 추천 유닛에 담아 결과물을 리턴한다.

