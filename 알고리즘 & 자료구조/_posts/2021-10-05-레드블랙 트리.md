### 1. 개요

\- BST는 최악의 경우 삽입/삭제/탐색에 O(n)의 시간이 걸리는 단점이 있어 여러 균형 BST가 제시되었다. 예를 들어 AVL 트리의 경우 이를 구성하는 모든 노드의 좌우 서브트리 높이차가 1 이하가 되도록 해 이러한 BST의 단점을 극복했는데, AVL 트리의 경우 삽입/삭제 때마다 '회전 연산'을 수행해야 하고 이 회전 연산의 수행 횟수가 (선형시간은 아니지만) 꽤 있을 수 있다는 단점이 있다.

\- 레드블랙 트리는 균형 BST의 하나로, AVL 트리와 유사하게 삽입/삭제 때마다 회전 연산 등의 연산을 하여 트리의 균형을 유지한다. 단, 여러 장치를 두어 회전 연산의 횟수가 최소화 될 수 있게 해 두었다. 따라서 평균적으로 레드블랙 트리가 AVL 트리보다 수행 시간이 적은 편이다.


### 2. 레드블랙 트리의 정의

#### 1) 모든 노드는 블랙 또는 레드 컬러를 갖고, **루트, 외부노드는 블랙 컬러**다.
#### 2) 블랙 노드끼리는 서로 부모자식 관계일 수 있으나, **레드 노드끼리는 부모자식 관계일 수 없다.**

\-  즉, 어떤 노드가 레드 컬러라면 그 노드의 부모와 그 노드의 자식은 반드시 모두 블랙 컬러다.

#### 3) 루트에서 외부노드로 이동하는 **모든 경로에서, 블랙 노드의 개수는 모두 동일**하다.

\- 레드 노드끼리는 부모자식 관계일 수 없다고 했으므로, 루트에서 외부노드로 이동하는 경로 중 레드 노드가 최대로 많은 경로라 해도 **그 경로의 레드 노드 수는 블랙 노드 수와 같다.** 따라서 레드블랙 트리의 외부노드들의 최대 깊이 차이는 전체 트리 높이의 절반이다.


### 3. 레드블랙 트리의 탐색시간의 상한

\- 레드블랙 트리의 노드 수 \\(n\\)인 어떤 레드블랙 트리가 있을 때, 이 레드블랙 트리가 갖는 루트에서 외부노드까지의 블랙 노드 수를 \\(r\\)이라고 하자. 그렇다면 이 레드블랙 트리의 탐색시간의 상한은 \\(2r\\)이 된다. 즉, \\(r\\)의 상한을 알 수 있다면 레드블랙 트리의 탐색시간의 상한을 알 수 있다.

\- 여기서 잠시 거꾸로 생각해서, 어떤 레드블랙 트리의 \\(r\\)이 주어질 때 이 레드블랙 트리가 가질 수 있는 노드 수 \\(n\\)의 하한에 대해 생각할 수 있다. 만약 이 문제로부터 \\(r\\)과 \\(n\\) 사이의 부등식을 구할 수 있다면, **이 부등식은 곧 \\(r\\)의 상한에 대한 부등식도 되므로** 이 문제에 대해 생각하는 것은 레드블랙 트리의 탐색시간의 상한을 구하는 데 있어 굉장히 중요한 일이 된다.

\- 그런데 레드블랙 트리가 가질 수 있는 노드수 \\(n\\)의 하한은 쉽게 생각할 수 있다. 루트부터 깊이가 \\(r\\)인 노드까지 모두 노드로 빽빽히 채워진 포화이진트리가 바로 \\(r\\)이 주어지는 레드블랙 트리의 \\(n\\)의 하한이다. 그리고 이를 구하는 부등식은 \\(r \leq log(n+1)\\) 이다.

\- 따라서 레드블랙 트리의 탐색시간의 상한은 \\(2log(n+1)\\)임을 알 수 있다. O 표기법으로 O(logn)으로 쓸 수 있다.


### 4. 레드블랙 트리의 삽입연산

#### 1) 새로 삽입되는 노드(\\(u\\))의 위치는 일단 일반적인 BST의 삽입 위치와 동일하게 찾는다. 그리고 \\(u\\)의 컬러는 레드로 한다.

#### 2) 이때 만약 \\(u\\)가 삽입된 위치의 **부모노드(\\(pu\\))의 컬러 또한 레드**라면, \\(pu\\)의 부모노드(\\(gu\\))의 \\(pu\\) 반대쪽 자식노드 _(\\(pu\\)가 \\(gu\\)의 왼쪽 자식이면 \\(gu_R\\), 오른쪽 자식이면 \\(gu_L\\) )_ 의 컬러에 따라 다음 연산을 선택적으로 수행한다.


(a) \\(gu_R\\) / \\(gu_L\\) 이 레드노드인 경우

\- 이 경우 \\(gu\\)의 두 자식이 모두 레드노드다. 이 경우에는 **각 노드들의 연결관계는 변경하지 않고, \\(gu\\)의 두 자식의 컬러를 블랙으로 \\(gu\\)의 컬러를 레드로 바꾼다.** 

\- \\(gu\\)가 레드노드가 되었는데 만약 그 부모노드가 레드노드인 경우, 위 2)번으로 돌아가 다시 루프를 수행한다.


(b) \\(gu_R\\) / \\(gu_L\\) 이 블랙노드인 경우

\- 레드블랙 트리라면 루트에서 외부노드까지 모든 경로의 블랙노드수가 모두 동일데, 이 경우에도 위 경우처럼 \\(gu\\)를 레드로 변경할 경우 몇몇 경로에서 블랙노드수가 감소되는 일이 일어나게 된다. 따라서 이 경우에는 컬러를 변경하지 않고, AVL 트리에서 한 것과 유사한 회전 연산을 수행한다.

\- 구체적으로, \\(u\\), \\(pu\\), \\(gu\\) 세 노드 중 **가운데 값을 갖는 노드를 부모노드로 나머지를 그 노드의 왼쪽/오른쪽 자식노드로** 붙인 후 각 세 노드가 갖고 있던 서브트리들을 BST의 규칙에 맞게 재배치하는 것이 회전 연산의 핵심 개념이다.

\- 이때 회전연산 후 새로 부모가 된 노드가 블랙 컬러고 나머지 노드가 레드 컬러를 갖게 한다. 이렇게 하면 더 이상 레드 노드끼리 연속돼서 부모-자식을 이루고 있는 경우가 더 이상 없어지므로, 이보다 더 상위 노드로 루프를 계속할 일 없이 삽입 연산이 여기서 바로 종료된다. 
