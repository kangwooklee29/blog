### 1. 쿼리를 대문자로 써야 하는 이유

\- 오라클의 경우 쿼리 입력 시 그 쿼리가 예전에 수행된 적 있는지를 탐색하는데, 이전에 같은 내용의 쿼리가 입력된 적 있어도 대소문자가 다르면 다른 쿼리가 입력된 것으로 보므로 캐시를 참조하지 않고 매번 새로 탐색을 수행하게 된다. 이는 비효율적이므로, 일반적으로 쿼리를 쓸 때 키워드와 속성명을 대문자 아니면 소문자로 일관적으로 쓰도록 하는 규칙을 정해두고 쿼리를 쓰게 된다. 그 외에도 대소문자에 관하여 일관된 규칙으로 쿼리를 쓰는 것이 가독성이 더 좋고 유지보수가 용이하다는 등의 장점이 있다.


### 2. SELECT 쿼리의 기본형태

```sql
SELECT table1.field1, table1.field2 FROM table1 {WHERE field1 < 10 ORDER BY field1, field2 DESC LIMIT 10}
```

\- 기본적으로 SELECT + 속성명 + FROM 테이블명의 형태를 갖고 있으며, 해당 테이블의 해당 속성명의 모든 값이 위에서 아래로 죽 나열된 튜플들을 가져오게 된다.


\- FROM 이하를 쓰지 않고, 속성명도 쓰지 않고 SELECT 1, 2, 3처럼 속성명 위치에 그냥 정수나 문자열을 두는 경우도 있다. 이 경우 다음 테이블을 결과로 가져온다.

| 1 | 2 | 3 |
|---|---|---|
| 1 | 2 | 3 |


### 3. 속성명 쓰기

#### 1) DISTINCT field1

\- field1의 값이 중복된 경우, 중복된 튜플을 제거한다.

#### 2) field1 AS 'field2'

\- 테이블에서 field1 속성의 값들을 가져오지만, 그 값의 속성명을 field2로 지정하여 가져온다.

#### 3) 그룹함수(COUNT, SUM, MAX, MIN, ...)

\- 그룹함수는 보통 다른 속성명을 쓰지 않고 단독으로 쓰지만, 그룹화 쿼리(GROUP BY)를 쓰는 경우 다른 속성명과 함께 쓰이기도 한다.

(a) COUNT(field1)

\- field1 속성의 값들을 만약 가져온다면 가져오게 될 튜플의 개수를 세서 **그 개수를 그 열의 유일한 튜플이 갖는 값으로 하는 열을 만들어 가져온다.**

\- field1 속성의 값 중 그 값이 null인 튜플이 있다면 그 튜플은 제외하고 개수를 센다. 단, 인자로 속성명이 아니라 **\*을 넣는다면 값이 null인 튜플을 포함**해 개수를 센다.


(b) SUM(field1), MAX(field1), MIN(field1)

\- field1 속성의 값들을 모두 합한 값/최댓값/최솟값을 그 열의 유일한 튜플이 갖는 값으로 하는 열을 만들어 가져온다.

#### 4) 문자열 관련 함수(LEFT, UPPER, LOWER, LEN, REPLACE, LPAD, RPAD, SUBSTRING, ...)

\- 속성명을 함수의 인자로 전달하면 그 함수에 해당하는 값으로 이루어진 열을 만들어 가져온다.


#### 5) field1 * 2

\- 속성명 위치에 그 속성명에 관한 연산식을 적을 수도 있다. 이 경우 각 튜플들에는 원래 그 위치에 반환됐어야 할 값의 연산값이 담기게 된다.


#### 6) CASE WHEN ... THEN ... END

```sql
CASE 
    WHEN field1 % 3 = 0 THEN '나머지 0' 
    WHEN field1 % 3 = 1 THEN '나머지 1'
    ELSE '나머지 2'
END
```

\- 각 튜플의 그 속성값이 조건식을 충족할 경우 **그에 해당하는 값(THEN 뒤에 쓰인 값)을 그 튜플이 그 열에서 갖는 값으로 하는 열을 만들어** 가져온다.

#### 7) IF(field1%2 = 0, '짝수', '홀수')

\- 각 튜플이 조건식을 충족하는 경우와 충족하지 않는 경우로 구분하여 각각 그에 해당하는 값을 그 튜플이 그 열에서 갖는 값으로 하는 열을 만들어 가져온다.

#### 8) DATE_FORMAT(field1, '%Y-%m-%d %H:%i:%s')

\- 각 튜플의 field1 값을 DATE_FORMAT 함수의 인자로 넣어 마찬가지로 인자로 전달된 **포맷 문자열에 대응되는 값**을 그 튜플이 그 열에서 갖는 값으로 하는 열을 만들어 가져온다.



### 4. 조건식 WHERE

#### 1) IS NULL, IS NOT NULL

\- NULL은 다른 값과 비교할 수 없고 TRUE나 FALSE와 논리연산 시 UNKNOWN 값이 리턴될 수 있음을 유의해야 한다.

#### 2) field1 BETWEEN 1 AND 10

\- field1의 값이 1과 10 사이 정수인 튜플을 가져온다.

#### 3) field1 IN (1, 3, 5, 7, 9) / field1 NOT IN (1, 3, 5, 7, 9)

\- field1의 값이 1, 3, 5, 7, 9 중 어느 하나인 튜플(또는 1, 3, 5, 7, 9가 아닌 튜플)을 가져온다.

\- 괄호 안에는 위와 같이 쉼표로 구분된 정수/문자열 대신 (SELECT field2 FROM table2)와 같은 SELECT 쿼리가 들어갈 수도 있다. 단, 이때 괄호 안에 들어가는 SELECT 쿼리는 속성명을 하나만 가져야 한다.

#### 4) filed1 LIKE '%오%'

\- field1의 값이 '오'를 포함하는 문자열인 튜플을 가져온다.



### 5. GROUP BY field1

```sql
SELECT field1, count(field1) AS cnt FROM table1 WHERE field1 >= 3 GROUP BY field1 HAVING cnt >= 2 ORDER BY field1 
```

\- 그룹함수와 함께 쓰며, 각 튜플이 그 속성명의 각 값과 그 값에 해당하는 그룹함수 값으로 이루어지는 **새로운 테이블을 만들어 가져온다.** 예를 들어, table1의 각 튜플들이 field1 속성에 대하여 각각 값이 1, 1, 3, 3, 5, 5라 할 때, 위 쿼리는 다음 테이블을 가져온다.

| field1 | cnt |
|---|---|
| 3 | 2 |
| 5 | 2 |

\- HAVING 뒤의 조건식은 GROUP BY로 테이블을 만들기 전에 **SELECT 쿼리로 구해진 결과값 중 해당 조건을 충족하는 튜플만을 새로 만들 테이블의 소스로** 하게 한다.


### 6. SELECT table1.field1 FROM table1 JOIN table2 ON table1.field1 = table2.field2

\- table1의 각 튜플의 field1 값이 table2의 어떤 튜플의 field2 값과 일치할 때 **그 두 튜플을 결합한 튜플들로 이루어진 테이블을 만들고** 그 테이블에서 지정된 속성명의 모든 값이 위에서 아래로 죽 나열된 튜플들을 가져온다. _(한편, ON 부분을 생략하면 table1의 모든 튜플에 table2의 모든 튜플을 각각 결합한 튜플들로 이루어진 새로운 테이블이 만들어진다.)_

- table1의 어떤 튜플의 field1값과 일치하는 **table2의 field2값이 없다면** 그 튜플은 가져오지 않는다. 단, **LEFT JOIN**의 경우 몇몇 속성명을 NULL로 남겨두는 한이 있더라도 **table1의 모든 튜플**을 가져온다.

- table1의 한 튜플의 field1값과 일치하는 **table2의 field2값이 여러 개라면** 그 튜플을 여러 개 만들고 일치하는 table2의 모든 튜플을 각 튜플에 모두 결합하여 가져온다.

- table2의 어떤 튜플의 field2값과 일치하는 table1의 field1값이 없다면 그 튜플은 가져오지 않는다. 단, **RIGHT JOIN**의 경우 몇몇 속성명을 NULL로 남겨두는 한이 있더라도 **table2의 모든 튜플**을 가져온다.

\- table1과 table2의 속성명이 일치하는 경우가 있더라도 일단 **두 속성명 모두 join된 결과 테이블에 존재**한다. 이때 각 속성명은 그 속성이 원래 있던 테이블명을 속성명 앞에 붙여 지칭한다.

\- FROM과 JOIN 뒤의 테이블명 뒤에 AS로 축약된 이름을 붙여 속성명이나 조건식에서 축약된 이름으로 그 테이블을 참조할 수 있다.


### 7. UNION, UNION ALL

\- 서로 다른 두 개의 SELECT 쿼리로 얻은 결과를 두 쿼리 사이에 UNION 연산자를 두어 이들을 결합해 하나의 결과로 만들 수 있다. 이때 UNION을 사용하면 앞의 결과와 뒤의 결과 중 완전히 일치하는 튜플(중복된 튜플)은 하나만 남겨두며, UNION ALL을 사용하면 중복을 버리지 않고 모두 하나의 결과로 결합시킨다.

\- 뒤의 SELECT 쿼리에 나온 속성명들은 무시되며 앞의 SELECT 쿼리에 나온 속성명을 순서대로 그대로 쓰게 된다.

\- 앞의 SELECT 쿼리에 나온 속성명의 개수는 뒤의 SELECT 쿼리에 나온 속성명의 개수와 완전히 일치해야 에러가 발생하지 않는다. 



### 8. WITH table1(field1, field2) AS (...)

#### 1) 개요

\- INSERT 쿼리로 새로운 DB 데이터를 DB에 추가하지 않고, WITH 쿼리를 사용하여 메모리에 임시로 새로운 테이블을 만들고 또 그 테이블에 이름을 붙여 그 테이블을 SELECT 쿼리로 호출하여 사용할 수 있다. 이처럼 메모리에 임시로 만든 테이블을 CTE(common table expression)이라 한다.

#### 2) WITH RECURSIVE table1 AS (...)

```sql
WITH RECURSIVE table1(field1, field2) AS (
    SELECT 0, 1 #초기값
    UNION
    SELECT field1+1, field2*2 FROM table1 WHERE field1 < 10
                #증감식, 조건식
)
```

\- WITH RECURSIVE 쿼리를 사용하면 반복문을 통해 만든 것과 같은 CTE를 만들 수 있다. 이러한 CTE는 초기값을 선언하는 SELECT 쿼리 하나와 증감식, 조건식을 모두 포함하는 SELECT 쿼리 하나를 사용하여 만든다. 구체적으로, 두 번째 SELECT 쿼리의 속성명에 그 CTE의 속성명을 사용한 연산식을 쓰면 그 SELECT 쿼리의 결과값이 재귀적으로 구해지게 된다. 이 재귀호출은 조건식에서 정한 조건이 참인 동안에만 일어난다.

