## 개요

- 컴퓨터 프로그래밍의 역사가 발전하면서 대규모 프로젝트를 개발하는 사례가 점차 늘어갔고, 이에 따라 대규모 프로젝트를 구현함에 있어 나타날 수 있는 유지보수, 모듈화, 확장성 등 여러 문제에 대한 인식이 나타나기 시작했다.

- 특히 1970년대에 그래픽 환경에서 유저 인터페이스를 제공하는 컴퓨터 시스템 구현을 시도했던 제록스의 Palo Alto Research Center (PARC)에서는 '스몰토크'라는 언어를 제시하였는데, 이는 상기한 복잡한 문제를 '객체'와 '클래스'라는 개념을 통해 해결하려는 시도였다. 이러한 논의로부터 촉발되어 '객체지향 프로그래밍'이라는 흐름이 나타나기 시작했으며, 특히 이러한 대규모 프로젝트 구현의 문제를 해결하는 것에 깊은 관심을 가진 덴마크 컴퓨터과학자 비야네 스트로스트룹이 제시한 C++이라는 언어가 대중화되어 객체지향 프로그래밍이 점차 대중화되기 시작했다.


## 객체지향 프로그래밍의 기본 아이디어

- 객체지향 프로그래밍은 전체 프로젝트를 여러 개의 객체로 나누어, 먼저 **하위 계층에서 각 객체를 높은 완성도로 구현**한 다음에 **보다 상위 계층에서는 객체의 구체적 구현에 대해 잘 모르고 각 객체와 메소드의 인터페이스에 대한 이해만 있더라도 그것만으로 전체 프로그램 로직을 아무 문제 없이 구현**할 수 있게 하는 것을 핵심으로 한다.

- 따라서 어떤 프로젝트를 객체지향 프로그래밍의 관점에서 높은 완성도로 개발한다는 것은, 전체 프로젝트를 얼마나 적절히 그리고 효율적으로 여러 객체로 잘 나누었는지와 깊은 관련이 있다. 예를 들어 대규모 프로젝트를 거의 수개 이하의 객체로 거의 나누지 않았다면, 이는 지나치게 하위 계층에서 구현돼야 할 코드를 전체 프로그램 로직 안에 그대로 들어가 있다는 뜻이 된다. 이렇게 되면 한 줄을 수정해도 그것이 전체 프로그램 로직에 어떤 영향을 줄지 파악하기 어려워, 프로그램의 유지보수 및 확장에 상당한 어려움이 발생한다.

  - 반대로 지나치게 많은 객체로 분리하는 것도 비슷한 문제가 발생할 수 있는데, 결국 전체 프로그램 로직에서 보이는 객체가 너무 많아지면 분리하지 않았을 때와 마찬가지로 지나치게 하위 계층이 그대로 전체 프로그램 로직에 노출된 것과 마찬가지가 되기 때문이다.


## 단일 책임 원칙(Single Responsibility Principle)

- 그러므로 객체지향 프로그래밍에서는 '무엇을 기준으로 객체를 분리할 것인가'가 가장 핵심적인 문제가 된다. 이에 관해 객체지향 프로그래밍에서 가장 널리 받아들여지는 원칙은 '단일 책임 원칙' 이다. 즉, '하나의 객체는 하나의 기능에 대해서만 책임을 가져야 한다' 라는 원칙으로, 소프트웨어 공학에서 흔히 이야기 되는 '관심사 분리(Separation of Concerns)'를 객체지향 프로그래밍의 관점에서 해석한 것으로 볼 수 있다.

  - 관심사 분리란 소프트웨어 공학 전반에서 널리 받아들여지는 개념으로, 관련 있는 개념들끼리는 서로 가까운 곳에서 잘 응집돼있고(high cohesion) 서로 관련 없는 개념들끼리는 낮은 결합도로 연결돼있어(loose coupling) 어느 하나의 수정이 다른 하나의 수정에 큰 영향을 미치지 않아야 한다는 개념이다. 객체지향 프로그래밍처럼 소프트웨어 구현에만 쓰이는 개념이 아니라, 프로그램의 구조 설계부터 개발 방법론, 분업 등 모든 분야에 걸쳐 두루 적용할 수 있는 개념이다.
 
- 단일 책임 원칙에서 '책임'이란 그 객체가 전체 프로젝트에서 가져야 하는 기능, 역할 따위를 의미한다. 구체적으로 어디서부터 어디까지를 '단일 책임'의 기준으로 할 것인지를 잘 판단하는 것이 단일 책임 원칙을 잘 지키고 있는 것인지를 결정한다.

  - 객체 내에 유사한 기능을 하는 코드들은 하나의 책임범위에 속한다고 볼 수 있다.
 
  - 만약 어떤 객체가 여러 개의 책임을 동시에 갖고 있다면, 그 객체는 전혀 다른 기능에 관한 변경을 수행하는 경우에도 번번히 변경이 일어날 것이다. 이 역시 그 객체가 단일 책임 원칙을 준수하는지 여부를 판단하는 기준이 될 수 있다.

- 객체지향 프로그래밍에서 단일 책임 원칙은 매우 중요한 원칙으로서, 대부분 조직의 개발 컨벤션이 이 원칙을 엄격히 지키도록 규칙을 설정하고 많은 프로그래밍 언어 또한 이러한 원칙을 따를 수 있는 수많은 제약 키워드를 설정한다.

  - 예를 들어 객체지향 프로그래밍에서 객체의 내부에서만 사용되는 변수나 기타 여러 구현을 객체 외부에서 알지 못하게 하는 것을 정보 은닉(information hiding)이라 하는데, 구체적으로 내부에서만 사용되는 변수를 `private`, `protected` 같은 키워드를 통해 선언해서 외부에서 접근 못하게 하고 접근은 getter, setter 함수를 통해서만 할 수 있게 하는 캡슐화(encapsulation) 등 기법을 통해 구현한다. 이는 외부에서 객체 내부의 상태를 함부로 변경하지 못하게 해서 객체의 무결성을 유지하게 하기 위함은 물론, 내부 구현만을 목적으로 사용되어 나중에 변경될 수도 있는 코드(특히 private 메소드)에 외부 객체가 의존하지 못하게 하기 위한 것으로, 이러한 제약사항이 준수된다는 사실을 통해 객체가 그 자체로 오직 하나의 기능에 대해 완전한 책임을 갖고 있음이 보장된다.

    - 뒤집어 말하면, 객체의 역할은 그 객체의 pubic 메소드/멤버변수로 어떤 것을 갖고 있는지를 통해 가늠할 수 있다. public 메소드/멤버변수가 서로간에 전혀 관련이 없는 것들이 있다면 이것으로 그 객체가 둘 이상의 책임을 갖고 있는 것으로 보고 새로운 객체를 추가한다든가 하는 판단을 할 수도 있다.

  
## 확장에는 열려있고, 변경에는 닫혀있다(Open-Close Principle)

- 객체지향 프로그래밍에서, 코드의 재사용성 및 확장성을 높이기 위한 원칙으로서 개방-폐쇄 원칙이 있다. 프로젝트가 커지게 되면 어떤 객체를 사용하여 어떤 코드 부분을 구현한 뒤에, **그 객체와 아주 기능이 유사하지만 그래도 일정 부분은 달라져야 하는 객체를 구현해서 사용**해야 하는 상황을 매우 자주 만나게 된다.

- 이때 비슷한 코드를 똑같이 새로 쓸 게 아니라, 프로그램을 확장에 열려있는 구조로 구현하면 아주 작은 코드 추가만으로도 기존 코드를 거의 그대로 쓰면서 새로운 상황에도 유연하게 대응 할 수 있다. 

  - 이를 구현하는 대표적 방법으로 '상속'이 있다. 어떤 클래스가 있다 하면, 이를 상속한 자식 클래스는 부모 클래스가 가진 모든 멤버 변수와 메소드를 똑같이 갖는 것이다. 단, 부모 클래스의 일부 멤버 변수나 메소드를 오버라이드 해서 내부 구현만은 전혀 새로 구현할 수 있다(polymorphism). 때문에 '확장에 열려있다'라는 것이 객체지향 프로그래밍에서 매우 중요한 개념인 것이다. 

    - 다형성(polymorphism): '메서드나 연산자가 이름이 같아 같은 방식으로 사용되나 다양한 방식으로 동작하여 다른 사용 결과(타입)를 갖는다'는 특성을 뜻한다. 오버라이딩 또는 오버로딩 등의 형태로 구현되며, 상속에서는 상기한 바와 같이 부모 클래스의 다른 메소드는 그대로 사용하면서 일부 구현 방식이 달라져야 하는 부분만 다르게 구현하도록 하는 형태로 활용된다. 코드의 재사용성, 유연성 및 확장성을 높이는 객체지향 프로그래밍의 중요한 특성이다.

  - 되도록 인터페이스/추상메소드를 갖는 클래스 형태를 정의해두어 새로운 클래스를 추가할 때 이를 상속/구현하도록 하는 것 또한 '확장에 열려있다'는 원칙에 부합한다. 이렇게 구현하면 기존 코드를 거의 그대로 재사용하는 것이 가능하다. 예를 들면, 메소드에서 인자를 인터페이스 또는 부모 클래스의 타입으로 전달받아 그 부모/인터페이스의 메소드를 사용하는 경우를 생각할 수 있다. 이 경우 그 부모 클래스/인터페이스를 상속/구현하는 클래스 또한 이 메소드의 인자로 전달돼 이 메소드의 코드를 그대로 재사용할 수 있다.

    - 이처럼 코드가 확장에 열려있어 굳이 변경이 필요하지 않은(변경에 닫힌) 상태로 구현된 코드가 객체지향 프로그래밍에서 바람직하다고 여겨지는 OCP를 만족하는 코드로 여겨지며, 반대로 확장에 닫혀 있어 새로운 객체의 추가가 필요하면 반드시 모든 코드의 상세한 변경이 필요한 상태를 객체지향에서 바람직하지 않다고 여겨지는 OCP를 위반하는 코드로 여겨진다.



## 리스코프 치환 원칙(Liskov Substitution Principle)

- 리스코프 치환 원칙이란 '자식 클래스에서 메소드를 오버라이드 하는 방향은 부모 클래스 메소드가 의도한 취지를 따라야 한다'라는 원칙을 뜻한다. 예를 들어 어떤 함수가 인자로 어떤 객체를 받고, 그 함수 내에서 그 객체의 메소드가 호출되고 있는 상황을 생각하자. 여기서 만약 인자로 그 객체의 클래스를 상속한 자식 클래스가 전달되는 경우가 있다 하면, 그 함수에서 그 인자 객체 메소드를 실행하는 부분은 인자로 전달된 객체가 자식 클래스더라도 부모 클래스 기준으로 작성된 코드의 의도에 따라 동작해야 하는 것이다. OCP와 마찬가지로, 자식 클래스를 구현하면서 객체지향 프로그래밍의 핵심 취지인 '상위 계층에서 객체의 구체적 구현에 대해 잘 모르고 각 객체와 메소드의 인터페이스에 대한 이해만 있더라도 그것만으로 전체 프로그램 로직을 아무 문제 없이 구현'이라는 내용을 실현하기 위해 반드시 준수해야 하는 중요한 원칙이다.

- 만약 자식 클래스를 구현할 때에 리스코프 치환 원칙을 준수하기 어려울 정도로 자식 클래스로 왔을 때 각 메소드의 의미가 크게 달라진다면(예를 들어, 부모 클래스로 `Rectangle` 을 정의하고 자식 클래스로 `Square` 를 정의한다면, `Square.setHeight()` 메소드가 갖는 기능은  `Rectangle.setHeight()` 메소드가 갖는 기능과 여러 면에서 다를 수밖에 없다), 이는 그 자식 클래스가 그 부모 클래스와 부모-자식 관계로 있을 수 없는 기능 및 개념을 갖고 있기 때문일 수 있다. 이러한 상황에서는 이 부모-자식 상속관계를 유지하기보다 인터페이스 등 새로운 상속관계를 정의하는 것이 대안이 될 수 있다.

- OCP와 LSP는 모두 클래스 간 상속 관계를 어떻게 하는 것이 적합한가에 관해 제시하는 원칙이지만, 주목하는 초점이 다르다. OCP는 '모듈, 인터페이스, 클래스 등의 설계가 확장에 열려있고, 변경에는 닫혀 있도록 하는 것이 바람직하다'라는 원칙이라면, LSP는 '자식 클래스를 구현할 때에는 그것이 부모 클래스의 설계 의도에 반하지 않도록 해야 한다'라는 원칙이라 할 수 있다. (각 원칙에 따라 구현하고 있음에도 불구하고 어느 한 원칙을 준수하는 것이 곤란한 상황일 경우 인터페이스 수정이 필요할 때가 있을 수 있다는 점에서 해결 방안이 유사한 경우가 있을 수 있기는 하다.)



## 인터페이스 분리 원칙(Interface Segregation Principle)

- '객체가 높은 응집도를 갖되 관련 없는 요소들끼리는 서로 낮은 결합도를 가져야 한다'라는 SRP와 유사하게, 인터페이스 또한 그 기능에 따라 적절히 높은 응집도를 갖는 요소들을 갖되 관련성 없는 요소들끼리 적절히 분리해야 한다는 것이 ISP다. 예를 들어, `Animal`이라는 이름의 거대한 인터페이스를 만들어 개와 새가 모두 이 인터페이스를 구현한다고 하면, 개는 사용하지 않는 'fly()' 메서드를 포함해야 할 수도 있다. 대신 `WalkableAnimal`, `FlyableAnimal`, `SwimmableAnimal` 같은 작고 구체적인 인터페이스로 분리하면, 각 동물 클래스가 자신에게 맞는 인터페이스만을 구현할 수 있다.



## 의존성 역전 원칙(Dependancy Inversion Principle)

- (전통적인 절차지향 프로그래밍의 관습과 같이) 프로그램 로직 내에서 일일이 매번 `new` 키워드로 구체적인 객체를 생성해서 쓸 게 아니라(high-level 모듈의 구현이 low-level 구현에 의존), 되도록 생성자의 인자로부터 추상화된 클래스 타입이나 인터페이스로서 객체를 전달받아 이로써 프로그램 내부 로직을 구현하도록 하는 것(high-level 모듈, low-level 모듈 모두 추상화)을 의존성 역전 원칙이라 한다. 

  - 절차지향 프로그래밍의 관습대로라면 `new` 키워드로 구체적인 객체를 생성하는 코드 뒤쪽의 모든 코드는 바로 그 `new` 키워드로 구체적인 객체를 생성한 코드에 의존하게 돼버리지만, 이렇게 생성자의 인자로 받은 객체를 그대로 저장, 사용하도록 코드를 구현하면 이후 코드가 생성자의 코드에 대한 의존관계가 되지는 않는다. 따라서 이를 '의존성 역전'이라 하는 것이다.

- 이처럼 전통적인 절차지향 프로그래밍의 의존관계를 역전하여 의존성 역전 원칙을 준수하는 코드를 구현하면, 객체 구현 내부적으로도 적절히 개념 간 관심사가 분리되어 코드의 유연성과 재사용성이 향상되고 테스트와 유지보수가 용이해지는 등 여러 중요한 이점이 있다.

- 이 원칙에서 제시된 '의존성 역전' 개념을 보다 확장, 발전시킨 디자인 패턴으로 제어의 역전(Inversion of Control) 디자인 패턴이 있다. 이는 객체의 생성 및 생명주기 관리를 애플리케이션 코드가 아닌 외부 컨테이너가 담당하게 하여, 객체 구현 및 관리상의 관심사 분리 수준을 한층 높인다. 
